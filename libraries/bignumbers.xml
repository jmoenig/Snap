<blocks app="Snap! 6, https://snap.berkeley.edu" version="1"><block-definition s="USE BIGNUMS %&apos;bool&apos;" type="command" category="operators"><comment w="303.3333333333333" collapsed="false">call with True to turn on the entire Scheme numeric tower, including infinite-precision integers, exact rationals, and complex numbers; call with False to restore native JavaScript arithmetic.</comment><header></header><code></code><translations>pt:altera utilização de aritmética do Scheme para _&#xD;</translations><inputs><input type="%b"></input></inputs><script><block s="doDeclareVariables"><list><l>isDone</l></list></block><block s="doSetVar"><l>isDone</l><block s="evaluate"><block s="reportJSFunction"><list><l>useBigNums</l></list><l>var done = false;&#xD;&#xD;function initialize (callback) {&#xD;    var bigScript = document.createElement(&apos;script&apos;);&#xD;    bigScript.src = &apos;//snap.berkeley.edu/snap/libraries/biginteger.js&apos;;&#xD;    bigScript.onload = loadScheme;&#xD;    document.head.appendChild(bigScript);&#xD;&#xD;    function loadScheme () {&#xD;        var schemeScript = document.createElement(&apos;script&apos;);&#xD;        schemeScript.src = &apos;//snap.berkeley.edu/snap/libraries/schemeNumber.js&apos;;&#xD;        schemeScript.onload = finish;&#xD;        document.head.appendChild(schemeScript);&#xD;    }&#xD;&#xD;    function finish () {&#xD;        makeGlobalObject();&#xD;        callback();&#xD;    }&#xD;}&#xD;&#xD;function makeGlobalObject () {&#xD;    window.bigNumbers = {&#xD;        originalEvaluate: InputSlotMorph.prototype.evaluate,&#xD;        originalChangeVar: VariableFrame.prototype.changeVar,&#xD;        originalPrims: {&#xD;            reportBasicSum: Process.prototype.reportBasicSum,&#xD;            reportBasicDifference: Process.prototype.reportBasicDifference,&#xD;            reportBasicProduct: Process.prototype.reportBasicProduct,&#xD;            reportBasicQuotient: Process.prototype.reportBasicQuotient,&#xD;            reportBasicPower: Process.prototype.reportBasicPower,&#xD;            reportBasicModulus: Process.prototype.reportBasicModulus,&#xD;            reportBasicAtan2: Process.prototype.reportBasicAtan2,&#xD;            reportRound: Process.prototype.reportRound,&#xD;            reportBasicMin: Process.prototype.reportBasicMin,&#xD;            reportBasicMax: Process.prototype.reportBasicMax,&#xD;            reportBasicRandom: Process.prototype.reportBasicRandom,&#xD;            reportBasicLessThan: Process.prototype.reportBasicLessThan,&#xD;            reportBasicGreaterThan: Process.prototype.reportBasicGreaterThan,&#xD;            reportEquals: Process.prototype.reportEquals,&#xD;            reportIsIdentical: Process.prototype.reportIsIdentical,&#xD;            reportMonadic: Process.prototype.reportMonadic&#xD;        }&#xD;    };&#xD;}&#xD;&#xD;function loadBlocks () {&#xD;    var fn = SchemeNumber.fn;&#xD;    var originalPrims = window.bigNumbers.originalPrims;&#xD;    if (useBigNums) {&#xD;        InputSlotMorph.prototype.evaluate = function () {&#xD;            var contents = this.contents();&#xD;            if (this.constant) {&#xD;                return this.constant;&#xD;            }&#xD;            if (this.isNumeric) {&#xD;                return parseNumber(contents.text || &apos;0&apos;);&#xD;            }&#xD;            return contents.text;&#xD;        };&#xD;        VariableFrame.prototype.changeVar = function (name, delta, sender) {&#xD;            var frame = this.find(name),&#xD;                value,&#xD;                newValue;&#xD;            if (frame) {&#xD;                value = parseNumber(frame.vars[name].value);&#xD;                newValue = Number.isNaN(value) ? delta : fn[&apos;+&apos;](value, parseNumber(delta));&#xD;                if (sender instanceof SpriteMorph &amp;&amp;&#xD;                        (frame.owner instanceof SpriteMorph) &amp;&amp;&#xD;                        (sender !== frame.owner)) {&#xD;                    sender.shadowVar(name, newValue);&#xD;                } else {&#xD;                    frame.vars[name].value = newValue;&#xD;                }&#xD;&#xD;            }&#xD;        };&#xD;        Object.assign(Process.prototype, {&#xD;            reportBasicSum: function (a, b) {&#xD;                a = parseNumber(a);&#xD;                b = parseNumber(b);&#xD;                if (Number.isNaN(a) || Number.isNaN(b)) return NaN;&#xD;                return fn[&apos;+&apos;](a, b);&#xD;            },&#xD;            reportBasicDifference: function (a, b) {&#xD;                a = parseNumber(a);&#xD;                b = parseNumber(b);&#xD;                if (Number.isNaN(a) || Number.isNaN(b)) return NaN;&#xD;                return fn[&apos;-&apos;](a, b);&#xD;            },&#xD;            reportBasicProduct: function (a, b) {&#xD;                a = parseNumber(a);&#xD;                b = parseNumber(b);&#xD;                if (Number.isNaN(a) || Number.isNaN(b)) return NaN;&#xD;                return fn[&apos;*&apos;](a, b);&#xD;            },&#xD;            reportBasicQuotient: function (a, b) {&#xD;                a = parseNumber(a);&#xD;                b = parseNumber(b);&#xD;                if (fn[&apos;=&apos;](b, &apos;0&apos;) &amp;&amp; !fn[&apos;=&apos;](a, &apos;0&apos;)) {&#xD;                      return (fn[&apos;&lt;&apos;](a, &apos;0&apos;) ? SchemeNumber(&apos;-inf.0&apos;) : SchemeNumber(&apos;+inf.0&apos;))&#xD;                };&#xD;                if (Number.isNaN(a) || Number.isNaN(b) || fn[&apos;=&apos;](b, &apos;0&apos;)) return NaN;&#xD;                return fn[&apos;/&apos;](a, b);&#xD;            },&#xD;            reportBasicPower: function (a, b) {&#xD;                a = parseNumber(a);&#xD;                b = parseNumber(b);&#xD;                if (Number.isNaN(a) || Number.isNaN(b)) return NaN;&#xD;                return fn[&apos;expt&apos;](a, b);&#xD;            },&#xD;            reportBasicModulus: function (a, b) {&#xD;                a = parseNumber(a);&#xD;                b = parseNumber(b);&#xD;                if (Number.isNaN(a) || Number.isNaN(b)) return NaN;&#xD;                var result = fn.mod(a, b);&#xD;                if (fn[&apos;&lt;&apos;](b, &apos;0&apos;) &amp;&amp; fn[&apos;&gt;&apos;](result, &apos;0&apos;)) {&#xD;                    result = fn[&apos;+&apos;](result, b);&#xD;                }&#xD;                return result;&#xD;            },&#xD;           reportBasicAtan2: function (a, b) {&#xD;                a = parseNumber(a);&#xD;                b = parseNumber(b);&#xD;                if (Number.isNaN(a) || Number.isNaN(b)) return NaN;&#xD;                return degrees(fn.atan2(a, b));&#xD;          },&#xD;          reportRound: function (n) {&#xD;             if (this.enableHyperOps) {&#xD;                 if (n instanceof List) {&#xD;                     return n.map(each =&gt; this.reportRound(each));&#xD;                 }&#xD;               }&#xD;           n = parseNumber(n);&#xD;           if (Number.isNaN(n)) return NaN;&#xD;           x = fn.round(n);&#xD;           if (fn["integer?"](x)) return fn["exact"](x);&#xD;           return x;&#xD;           },  &#xD;           reportBasicMin: function (a, b) {&#xD;                x = parseNumber(a);&#xD;                y = parseNumber(b);&#xD;                if (Number.isNaN(x) || Number.isNaN(y)) {&#xD;                  return a&lt;b ? a : b;&#xD;                }&#xD;                return fn[&apos;&lt;&apos;](x, y) ? x : y;&#xD;            },&#xD;           reportBasicMax: function (a, b) {&#xD;                x = parseNumber(a);&#xD;                y = parseNumber(b);&#xD;                if (Number.isNaN(x) || Number.isNaN(y)) {&#xD;                  return a&gt;b ? a : b;&#xD;                }&#xD;                return fn[&apos;&gt;&apos;](x, y) ? x : y;&#xD;            },&#xD;            reportBasicRandom: function (min, max) {&#xD;                var floor = parseNumber(min),&#xD;                    ceil = parseNumber(max);&#xD;                if (Number.isNaN(floor) || Number.isNaN(ceil)) return NaN;&#xD;                if (!fn[&apos;=&apos;](fn.mod(floor, &apos;1&apos;), &apos;0&apos;) || !fn[&apos;=&apos;](fn.mod(ceil, &apos;1&apos;), &apos;0&apos;)) {&#xD;                    // One of the numbers isn&apos;t whole. Include the decimal.&#xD;                    return fn[&apos;+&apos;](&#xD;                        fn[&apos;*&apos;](&#xD;                            Math.random(),&#xD;                            fn[&apos;-&apos;](ceil, floor)&#xD;                        ),&#xD;                        floor&#xD;                    );&#xD;                }&#xD;                var size = Math.ceil(max.toString(10).length/14);&#xD;                const array = new Uint32Array(size);&#xD;                window.crypto.getRandomValues(array);&#xD;                var digits="";&#xD;                for (i=0;i&lt;size;i++) {&#xD;                    digits = digits + array[i].toString();&#xD;               } &#xD;               return fn.floor(&#xD;                    fn[&apos;+&apos;](&#xD;                        // fn[&apos;*&apos;](&#xD;                         //   Math.random(),&#xD;                            fn.mod(parseNumber(digits),&#xD;                                 fn[&apos;+&apos;](&#xD;                                     fn[&apos;-&apos;](ceil, floor),&#xD;                                     &apos;1&apos;&#xD;                                 )&#xD;                             ),&#xD;                        floor&#xD;                    )&#xD;                );&#xD;            },&#xD;            reportBasicLessThan: function (a, b) {&#xD;                x = parseNumber(a);&#xD;                y = parseNumber(b);&#xD;                if (Number.isNaN(x) || Number.isNaN(y)) return a&lt;b;&#xD;                return fn[&apos;&lt;&apos;](x, y);&#xD;            },&#xD;            reportBasicGreaterThan: function (a, b) {&#xD;                x = parseNumber(a);&#xD;                y = parseNumber(b);&#xD;                if (Number.isNaN(x) || Number.isNaN(y)) return a&gt;b;&#xD;                return fn[&apos;&gt;&apos;](x, y);&#xD;            },&#xD;            reportEquals: function (a, b) {&#xD;                x = parseNumber(a);&#xD;                y = parseNumber(b);&#xD;                if (Number.isNaN(x) || Number.isNaN(y)) return snapEquals(a, b);&#xD;                return fn[&apos;=&apos;](x, y);&#xD;            },&#xD;            reportIsIdentical: function (a, b) {&#xD;                x = parseNumber(a);&#xD;                y = parseNumber(b);&#xD;                if (Number.isNaN(x) || Number.isNaN(y)) return originalPrims.reportIsIdentical(a, b);&#xD;                return fn[&apos;=&apos;](x, y);&#xD;            },&#xD;            reportMonadic: function (fname, n) {&#xD;                if (this.enableHyperOps) {&#xD;                    if (n instanceof List) {&#xD;                        return n.map(each =&gt; this.reportMonadic(fname, each));&#xD;                    }&#xD;                }&#xD;&#xD;                n = parseNumber(n);&#xD;                if (Number.isNaN(n)) return NaN;&#xD;&#xD;                switch (Process.prototype.inputOption(fname)) {&#xD;                case &apos;abs&apos;:&#xD;                    return fn.abs(n);&#xD;                case &apos;neg&apos;:&#xD;                    return fn[&apos;-&apos;](n);&#xD;                case &apos;sign&apos;:&#xD;                     if (fn[&apos;=&apos;](n,SchemeNumber(&apos;0&apos;))) return SchemeNumber(&apos;0&apos;);&#xD;                     return fn[&apos;/&apos;](n, fn.abs(n));&#xD;                case &apos;ceiling&apos;:&#xD;                    return fn.ceiling(n);&#xD;                case &apos;floor&apos;:&#xD;                    return fn.floor(n);&#xD;                case &apos;sqrt&apos;:&#xD;                    return sqrt(n);&#xD;                case &apos;sin&apos;:&#xD;                    return fn.sin(radians(n));&#xD;                case &apos;cos&apos;:&#xD;                    return fn.cos(radians(n));&#xD;                case &apos;tan&apos;:&#xD;                    return fn.tan(radians(n));&#xD;                case &apos;asin&apos;:&#xD;                    return degrees(fn.asin(n));&#xD;                case &apos;acos&apos;:&#xD;                    return degrees(fn.acos(n));&#xD;                case &apos;atan&apos;:&#xD;                    return degrees(fn.atan(n));&#xD;                case &apos;ln&apos;:&#xD;                    return fn.log(n);&#xD;                case &apos;log&apos;:&#xD;                    return fn.log(n, &apos;10&apos;);&#xD;                case &apos;lg&apos;:&#xD;                    return fn.log(n, &apos;2&apos;);&#xD;                case &apos;e^&apos;:&#xD;                    return fn.exp(n);&#xD;                case &apos;10^&apos;:&#xD;                    return fn.expt(&apos;10&apos;, n);&#xD;                case &apos;2^&apos;:&#xD;                    return fn.expt(&apos;2&apos;, n);&#xD;                case &apos;id&apos;:&#xD;                    return n;&#xD;                default:&#xD;                    return SchemeNumber(&apos;0&apos;);&#xD;                }&#xD;            }&#xD;        });&#xD;    } else {&#xD;        InputSlotMorph.prototype.evaluate = window.bigNumbers.originalEvaluate;&#xD;        VariableFrame.prototype.changeVar = window.bigNumbers.originalChangeVar;&#xD;        Object.assign(Process.prototype, originalPrims);&#xD;    }&#xD;    done = true;&#xD;}&#xD;&#xD;function parseNumber (n) {&#xD;    var fn = SchemeNumber.fn;&#xD;    if (!fn[&apos;number?&apos;](n)) {&#xD;        n = &apos;&apos; + n;&#xD;        try {&#xD;            return parseENotation(n) || SchemeNumber(n);&#xD;        } catch (err) {&#xD;            return NaN;&#xD;        }&#xD;    }&#xD;    return n;&#xD;}&#xD;&#xD;function parseENotation (n) {&#xD;    var fn = SchemeNumber.fn;&#xD;&#xD;    var numbers = n.match(/^(-?\d+\.?\d*|-?\.\d+)e(-?\d+)$/i);&#xD;    if (!numbers) return null;&#xD;&#xD;    var coefficient = numbers[1];&#xD;    var exponent = numbers[2];&#xD;    return fn[&apos;*&apos;](&#xD;        coefficient,&#xD;        fn.expt(&apos;10&apos;, exponent)&#xD;    );&#xD;}&#xD;&#xD;function sqrt (n) {&#xD;    var fn = SchemeNumber.fn;&#xD;&#xD;    if (!fn[&apos;exact?&apos;](n) || !fn[&apos;rational?&apos;](n) || fn[&apos;&lt;&apos;](n,&apos;0&apos;)) return fn.sqrt(n);&#xD;&#xD;    var rootNumerator = fn[&apos;exact-integer-sqrt&apos;](fn.numerator(n));&#xD;    if (!fn[&apos;=&apos;](rootNumerator[1], &apos;0&apos;)) return fn.sqrt(n);&#xD;&#xD;    var rootDenominator = fn[&apos;exact-integer-sqrt&apos;](fn.denominator(n));&#xD;    if (!fn[&apos;=&apos;](rootDenominator[1], &apos;0&apos;)) return fn.sqrt(n);&#xD;&#xD;    return fn[&apos;/&apos;](rootNumerator[0], rootDenominator[0]);&#xD;}&#xD;&#xD;&#xD;function isDone () {&#xD;    return done;&#xD;}&#xD;&#xD;if (window.bigNumbers) {&#xD;    loadBlocks();&#xD;} else {&#xD;    initialize(loadBlocks);&#xD;}&#xD;&#xD;return isDone;</l></block><list><block var="bool"/></list></block></block><block s="doWaitUntil"><block s="evaluate"><block var="isDone"/><list></list></block></block></script></block-definition><block-definition s="%&apos;n&apos; !" type="reporter" category="operators"><comment x="0" y="0" w="190.66666666666666" collapsed="false">The factorial function, to make very large numbers, to demo bignums.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doReport"><block s="reportIfElse"><block s="reportEquals"><block var="n"/><l>0</l></block><l>1</l><block s="reportProduct"><block var="n"/><custom-block s="%n !"><block s="reportDifference"><block var="n"/><l>1</l></block></custom-block></block></block></block></script></block-definition><block-definition s="%&apos;x&apos;" type="reporter" category="operators"><comment x="0" y="0" w="234.66666666666666" collapsed="false">The identity function: reports its input.&#xD;It&apos;s useful to get things like 3/4 or 5-2i into&#xD;numeric input slots.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block var="x"/></block></script></block-definition><block-definition s="Scheme number %&apos;function&apos; of %&apos;number&apos;" type="reporter" category="operators"><comment x="0" y="0" w="300" collapsed="true">Provides Scheme arithmetic functions not in JavaScript</comment><header></header><code></code><translations>pt:_ de _&#xD;</translations><inputs><input type="%s" readonly="true"><options>number?&#xD;complex?&#xD;real?&#xD;rational?&#xD;integer?&#xD;exact?&#xD;inexact?&#xD;exact&#xD;inexact&#xD;finite?&#xD;infinite?&#xD;nan?&#xD;numerator&#xD;denominator&#xD;real-part&#xD;imag-part&#xD;magnitude&#xD;angle</options></input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>which</l><l>num</l></list><l>function parseNumber (n) {&#xD;    var fn = SchemeNumber.fn;&#xD;    if (!fn[&apos;number?&apos;](n)) {&#xD;        n = &apos;&apos; + n;&#xD;        try {&#xD;            return parseENotation(n) || SchemeNumber(n);&#xD;        } catch (err) {&#xD;            return NaN;&#xD;        }&#xD;    }&#xD;    return n;&#xD;}&#xD;&#xD;function parseENotation (n) {&#xD;    var fn = SchemeNumber.fn;&#xD;&#xD;    var numbers = n.match(/^(-?\d+\.?\d*|-?\.\d+)e(-?\d+)$/i);&#xD;    if (!numbers) return null;&#xD;&#xD;    var coefficient = numbers[1];&#xD;    var exponent = numbers[2];&#xD;    return fn[&apos;*&apos;](&#xD;        coefficient,&#xD;        fn.expt(&apos;10&apos;, exponent)&#xD;    );&#xD;}&#xD;var fn=SchemeNumber.fn,&#xD;      number=parseNumber(num);&#xD;&#xD;switch (which) {&#xD;  case &apos;number?&apos;:&#xD;  case &apos;complex?&apos;:&#xD;    return (fn[&apos;number?&apos;](number));&#xD;  case &apos;real?&apos;:&#xD;    return (fn[&apos;real?&apos;](number) || fn[&apos;real-valued?&apos;](number));&#xD;  case &apos;rational?&apos;:&#xD;    return (fn[&apos;rational?&apos;](number) || (fn[&apos;=&apos;](number, fn.rationalize(number, parseNumber(&apos;1.0e-5&apos;)))));&#xD;  case &apos;integer?&apos;:&#xD;    return (fn[&apos;integer?&apos;](number) || fn[&apos;integer-valued?&apos;](number));&#xD;  case &apos;exact?&apos;:&#xD;  case &apos;inexact?&apos;:&#xD;  case &apos;finite?&apos;:&#xD;  case &apos;infinite?&apos;:&#xD;  case &apos;nan?&apos;:&#xD;  case &apos;real-part&apos;:&#xD;  case &apos;imag-part&apos;:&#xD;    return (fn[which](number));&#xD;  case &apos;magnitude&apos;:&#xD;    return (fn.magnitude(number));&#xD;  case &apos;angle&apos;:&#xD;    return (fn.angle(number));&#xD;  case &apos;numerator&apos;:&#xD;    return (fn.numerator(number));&#xD;  case &apos;denominator&apos;:&#xD;    return (fn.denominator(number));&#xD;  case &apos;exact&apos;:&#xD;    return (fn.exact(number));&#xD;case &apos;inexact&apos;:&#xD;    return (fn.inexact(number));&#xD;}</l></block><list><block var="function"/><block var="number"/></list></block></block></script></block-definition></blocks>