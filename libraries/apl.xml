<blocks app="Snap! 6, https://snap.berkeley.edu" version="1"><block-definition s="reshape as %&apos;shape&apos; $⍴-1-255-255-0 items of %&apos;data&apos;" type="reporter" category="lists"><comment w="180" collapsed="false">The first input is a shape list as in&#xD;SHAPE OF.  The output is an array with those dimensions containing  the atomic items of the second input,&#xD;repeating values if more are needed.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="reshape helper %l %l"><block var="shape"/><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><block var="data"/></custom-block></custom-block></block></script></block-definition><block-definition s="shape of $⍴-1-255-255-0 %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="310" collapsed="false">Reports a flat list of the maximum size of the input array along&#xD;each dimension: number of rows, number of columns, etc.&#xD;&quot;Maximum&quot; because it works even if the array isn&apos;t uniformly shaped.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doDeclareVariables"><list><l>sublists</l></list></block><block s="doIfElse"><block s="reportIsA"><block var="data"/><l><option>list</option></l></block><script><block s="doSetVar"><l>sublists</l><block s="reportKeep"><block s="reifyPredicate"><autolambda><block s="reportNot"><block s="reportListIsEmpty"><l/></block></block></autolambda><list></list></block><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="shape of $⍴-1-255-255-0 %l"><l/></custom-block></autolambda><list></list></block><block var="data"/></block></block></block><block s="doIfElse"><block s="reportListIsEmpty"><block var="sublists"/></block><script><block s="doReport"><block s="reportNewList"><list><block s="reportListLength"><block var="data"/></block></list></block></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportListLength"><block var="data"/></block><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportCombine"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><block var="number"/><l/></block></autolambda><list></list></block><block var="sublists"/></block><block s="reifyReporter"><autolambda><custom-block s="max %s $⌈-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block></block></autolambda><list><l>number</l></list></block><block s="reportNumbers"><l>1</l><block s="reportCombine"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListLength"><l/></block></autolambda><list></list></block><block var="sublists"/></block><block s="reifyReporter"><autolambda><custom-block s="max %s $⌈-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block></block></block></block></custom-block></block></block></script></block></script><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block></script></block-definition><block-definition s="max %&apos;a&apos; $⌈-1-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="150.66666666666666" collapsed="false">Reports the greater of its two inputs. Works on strings too.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><block s="reportIfElse"><block s="reportGreaterThan"><block var="a"/><block var="b"/></block><block var="a"/><block var="b"/></block></autolambda><list><l>a</l><l>b</l></list></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="flatten (ravel) $,-1-255-255-0 %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="216" collapsed="false">Reports a flat list of all the atomic elements &#xD;of sublists of the input list.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="data"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportConcatenatedLists"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><l/></custom-block></autolambda><list></list></block><block var="data"/></block></block></block></script><script><block s="doReport"><block s="reportNewList"><list><block var="data"/></list></block></block></script></block></script></block-definition><block-definition s="outer product %&apos;a&apos; $○.-1-255-255-0 %&apos;function&apos; %&apos;b&apos;" type="reporter" category="lists"><comment x="0" y="0" w="297.99999999999994" collapsed="false">Given two arrays A and B, reports an array whose dimensions are&#xD;APPEND(SHAPE OF (A), SHAPE OF (B))&#xD;in which each atomic item of the result is computed by applying the dyadic function input to an item of A and an item of B.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="a"/></custom-block><l>0</l></block><script><block s="doReport"><block s="evaluate"><block var="function"/><list><block var="a"/><block var="b"/></list></block></block></script></block><block s="doIf"><block s="reportListIsEmpty"><block var="a"/></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doReport"><block s="reportCONS"><custom-block s="outer product %l $○.-1-255-255-0 %repRing %l"><block s="reportListItem"><l>1</l><block var="a"/></block><block var="function"/><block var="b"/></custom-block><custom-block s="outer product %l $○.-1-255-255-0 %repRing %l"><block s="reportCDR"><block var="a"/></block><block var="function"/><block var="b"/></custom-block></block></block></script></block-definition><block-definition s="identity $+-1-255-255-0 %&apos;x&apos;" type="reporter" category="operators"><comment x="0" y="0" w="210.00000000000003" collapsed="false">Reports its input.&#xD;This is useful to fit a value into a different-type input slot, e.g., number into list slot.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block var="x"/></block></script></block-definition><block-definition s="rank of $⍴⍴-1-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="240" collapsed="true">Reports the number of dimensions of the input.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportListItem"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></custom-block></block></block></script></block-definition><block-definition s="inner product helper with %&apos;plus&apos; . %&apos;times&apos; %&apos;a&apos; transposed %&apos;tb&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%repRing"></input><input type="%l"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="a"/></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block s="reportListItem"><l>1</l><block s="reportListItem"><l>1</l><block var="a"/></block></block><l><option>list</option></l></block></block><script><block s="doReport"><block s="reportCONS"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="generalized dotproduct %l %l with sum %repRing product %repRing"><block s="reportListItem"><l>1</l><block var="a"/></block><l/><block var="plus"/><block var="times"/></custom-block></autolambda><list></list></block><block var="tb"/></block><custom-block s="inner product helper with %repRing . %repRing %l transposed %l"><block var="plus"/><block var="times"/><block s="reportCDR"><block var="a"/></block><block var="tb"/></custom-block></block></block></script></block><block s="doReport"><block s="reportCONS"><custom-block s="inner product helper with %repRing . %repRing %l transposed %l"><block var="plus"/><block var="times"/><block s="reportListItem"><l>1</l><block var="a"/></block><block var="tb"/></custom-block><custom-block s="inner product helper with %repRing . %repRing %l transposed %l"><block var="plus"/><block var="times"/><block s="reportCDR"><block var="a"/></block><block var="tb"/></custom-block></block></block></script></block-definition><block-definition s="transpose $⍉-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment w="168" collapsed="false">Takes a multidimensional array, and&#xD;reports an array whose dimensions&#xD;are reversed (as reported by&#xD;SHAPE OF).  In the case of a&#xD;two-dimensional array, does the usual transposition of rows and columns.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="array"/><l><option>list</option></l></block></block><script><block s="doReport"><block var="array"/></block></script></block><block s="doIf"><block s="reportListIsEmpty"><block var="array"/></block><script><block s="doReport"><block s="reportNewList"><list><block s="reportNewList"><list></list></block></list></block></block></script><comment w="290.6666666666667" collapsed="true">If there are no atomic data, we don&apos;t have any shape information, so we can&apos;t really transpose it.  But an empty list is 0 rows of some number of columns, so the transpose should be 0 columns in some number of rows.  We arbitrarily make it 0 columns of one row.  This at least has one dimension of the shape correct.</comment></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block s="reportListItem"><l>1</l><block var="array"/></block><l><option>list</option></l></block></block><script><block s="doReport"><block var="array"/></block></script><comment w="274.6666666666667" collapsed="true">The transpose of a vector is just the vector itself.</comment></block><block s="doIf"><block s="reportListIsEmpty"><block s="reportListItem"><l>1</l><block var="array"/></block></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><comment w="274.6666666666667" collapsed="true">This is the opposite no-atomic-data situation from above.  We know that there are (length array) rows of 0 columns, so the transpose is 0 rows, i.e., an empty list.  But we lose the number of original rows, transpose columns.</comment></block><block s="doReport"><custom-block s="deep map %repRing %predRing %l"><block s="reifyReporter"><autolambda><custom-block s="nth item 1 %n %l"><block s="reportListLength"><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></block><block s="reportListItem"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportNewList"><list><l></l></list></block></autolambda><list></list></block><block var="atom"/></block><block var="array"/></block></custom-block></autolambda><list><l>atom</l></list></block><block s="reifyPredicate"><autolambda><block s="reportCombine"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportNot"><block s="reportIsA"><l></l><l><option>list</option></l></block></block></autolambda><list></list></block><block var="node"/></block><block s="reifyReporter"><autolambda><block s="reportAnd"><l/><l/></block></autolambda><list></list></block></block></autolambda><list><l>node</l></list></block><custom-block s="$⍳-1.5-255-255-0 %n"><custom-block s="reverse row order (column contents) $⦵-1.5-255-255-0 %l"><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></custom-block></custom-block></custom-block></block></script><scripts><script x="690.0310872395834" y="485.55555555555566"><block var="array"/></script><script x="544.6666666666666" y="306.1111111111114"><block s="doIf"><block s="reportListIsEmpty"><block s="reportCDR"><block var="array"/></block></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportNewList"><list><l></l></list></block></autolambda><list></list></block><block s="reportListItem"><l>1</l><block var="array"/></block></block></block></script><comment w="212.66666666666666" collapsed="true">This is one row, n columns.  So the transpose is n rows, one column.</comment></block></script></scripts></block-definition><block-definition s="reverse row order (column contents) $⦵-1.5-255-255-0 %&apos;list&apos;" type="reporter" category="lists"><comment w="286" collapsed="false">Reverses the order of the (toplevel) items of the input.&#xD;&#xD;If the input is a matrix, this means it reverses the order of the rows, which is a reflection through a horizontal axis, as the ⦵ symbol suggests.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="list"/></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l></l><block var="list"/></block></autolambda><list></list></block><block s="reportNumbers"><block s="reportListLength"><block var="list"/></block><l>1</l></block></block></block></script></block-definition><block-definition s="deep insert %&apos;first&apos; %&apos;rest&apos;" type="reporter" category="other"><comment x="0" y="0" w="131.33333333333334" collapsed="false">Recursively deep-inserts&#xD;the items of the first input&#xD;into the items of the second&#xD;input.  If the first input is not&#xD;a list, then it is inserted with&#xD;IN FRONT OF in the second&#xD;unless the second also isn&apos;t&#xD;a list, in which case they are&#xD;combined with LIST.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="first"/><l><option>list</option></l></block></block><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="rest"/><l><option>list</option></l></block></block><script><block s="doReport"><block s="reportNewList"><list><block var="first"/><block var="rest"/></list></block></block></script></block><block s="doReport"><block s="reportCONS"><block var="first"/><block var="rest"/></block></block></script></block><block s="doIf"><block s="reportAnd"><block s="reportNot"><block s="reportIsA"><block s="reportListItem"><l>1</l><block var="first"/></block><l><option>list</option></l></block></block><block s="reportListIsEmpty"><block s="reportCDR"><block var="first"/></block></block></block><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="first"/></block><block var="rest"/></block></block></script></block><block s="doReport"><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><autolambda><custom-block s="deep insert %l %l"><l/><l/></custom-block></autolambda><list></list></block><list><block var="first"/><block var="rest"/></list></custom-block></block></script></block-definition><block-definition s="multimap %&apos;function&apos; %&apos;data&apos;" type="reporter" category="other"><comment x="0" y="0" w="215.33333333333334" collapsed="false">Like MAP, but can take any number of lists&#xD;as inputs.  The lists must all be the same size.&#xD;The function input must take a number of inputs&#xD;equal to the number of lists.  MULTIMAP calls&#xD;the function with all the first items, then all the&#xD;second items, and so on.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%mult%l"></input></inputs><script><block s="doIf"><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block s="reifyReporter"><autolambda><block s="reportOr"><l/><l/></block></autolambda><list></list></block><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListIsEmpty"><l/></block></autolambda><list></list></block><block var="data"/></block></custom-block><script><block s="doIfElse"><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block s="reifyReporter"><autolambda><block s="reportAnd"><l/><l/></block></autolambda><list></list></block><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListIsEmpty"><l/></block></autolambda><list></list></block><block var="data"/></block></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><custom-block s="error %txt"><l>Non-conforming shapes.</l></custom-block></script></block></script></block><block s="doReport"><block s="reportCONS"><block s="evaluate"><block var="function"/><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l>1</l><l/></block></autolambda><list></list></block><block var="data"/></block></block><custom-block s="multimap %repRing %mult%l"><block var="function"/><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportCDR"><l/></block></autolambda><list></list></block><block var="data"/></block></custom-block></block></block></script></block-definition><block-definition s="printable %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="188.66666666666666" collapsed="false">Takes a (possibly deep) list as input,&#xD;and reports a human-readable text form &#xD;of the list (namely, Lisp notation).</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="data"/><l><option>list</option></l></block></block><script><block s="doReport"><block var="data"/></block></script></block><block s="doIf"><block s="reportListIsEmpty"><block var="data"/></block><script><block s="doReport"><l>()</l></block></script></block><block s="doReport"><block s="reportJoinWords"><list><l>(</l><block s="reportCombine"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="printable %l"><l/></custom-block></autolambda><list></list></block><block var="data"/></block><block s="reifyReporter"><autolambda><block s="reportJoinWords"><list><l></l><l> </l><l></l></list></block></autolambda><list></list></block></block><l>)</l></list></block></block></script></block-definition><block-definition s="generalized dotproduct %&apos;a&apos; %&apos;b&apos; with sum %&apos;sum&apos; product %&apos;product&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input><input type="%repRing"></input><input type="%repRing"></input></inputs><script><block s="doReport"><block s="reportCombine"><custom-block s="multimap %repRing %mult%l"><block var="product"/><list><block var="a"/><block var="b"/></list></custom-block><block var="sum"/></block></block></script></block-definition><block-definition s="inner product %&apos;a&apos; %&apos;plus&apos; $.-1-255-255-0 %&apos;times&apos; %&apos;b&apos;" type="reporter" category="lists"><comment x="0" y="0" w="252.66666666666666" collapsed="false">Computes a generalized matrix multiplication.&#xD;&#xD;In normal matrix multiplication, each cell of the result&#xD;is computed by multiplying individual numbers within&#xD;a row of the left input and a column of the right input,&#xD;and then adding those products.  In APL terms this is&#xD;+.× (&quot;plus dot times&quot;)&#xD;Any dyadic functions can replace addition and multiplication in this algorithm; a common case is&#xD;∨.∧ (&quot;or dot and&quot;)</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%repRing"></input><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="a"/><l><option>list</option></l></block></block><script><block s="doSetVar"><l>a</l><block s="reportNewList"><list><block var="a"/></list></block></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="b"/><l><option>list</option></l></block></block><script><block s="doSetVar"><l>b</l><block s="reportNewList"><list><block var="b"/></list></block></block></script></block><block s="doIf"><block s="reportAnd"><block s="reportEquals"><block s="reportListItem"><l><option>last</option></l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="a"/></custom-block></block><l>1</l></block><block s="reportGreaterThan"><block s="reportListItem"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="b"/></custom-block></block><l>1</l></block></block><script><block s="doDeclareVariables"><list><l>ta</l></list></block><block s="doSetVar"><l>ta</l><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="a"/></custom-block></block><block s="doSetVar"><l>a</l><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block s="reportMap"><block s="reifyReporter"><autolambda><block var="ta"/></autolambda><list></list></block><block s="reportNumbers"><l>1</l><block s="reportListItem"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="b"/></custom-block></block></block></block></custom-block></block></script></block><block s="doIf"><block s="reportAnd"><block s="reportGreaterThan"><block s="reportListItem"><l><option>last</option></l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="a"/></custom-block></block><l>1</l></block><block s="reportEquals"><block s="reportListItem"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="b"/></custom-block></block><l>1</l></block></block><script><block s="doSetVar"><l>b</l><block s="reportMap"><block s="reifyReporter"><autolambda><block var="b"/></autolambda><list></list></block><block s="reportNumbers"><l>1</l><block s="reportListItem"><l><option>last</option></l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="a"/></custom-block></block></block></block></block></script></block><block s="doReport"><custom-block s="inner product helper with %repRing . %repRing %l transposed %l"><block var="plus"/><block var="times"/><block var="a"/><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="b"/></custom-block></custom-block></block></script></block-definition><block-definition s="min %&apos;a&apos; $⌊-1.2-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="211.33333333333334" collapsed="true">Reports the smaller of its two inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><block s="reportIfElse"><block s="reportLessThan"><block var="a"/><block var="b"/></block><block var="a"/><block var="b"/></block></autolambda><list><l>a</l><l>b</l></list></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="log base %&apos;b&apos; $⍟-1.5-255-255-0 %&apos;x&apos;" type="reporter" category="operators"><comment x="0" y="0" w="212" collapsed="false">Computes logarithms in any base.&#xD;&#xD;The base is the left input.  It&apos;s usual in APL that if there&apos;s a main data input and some sort of control input, the latter comes on the left.  This is because APL syntax, unless you use parentheses, groups computations from right to left.&#xD;&#xD;APL has a monadic version of this function that computes natural logs (log to the base e).</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><block s="reportQuotient"><block s="reportMonadic"><l><option>ln</option></l><block var="x"/></block><block s="reportMonadic"><l><option>ln</option></l><block var="b"/></block></block></autolambda><list><l>b</l><l>x</l></list></block></custom-block><list><block var="b"/><block var="x"/></list></block></block></script></block-definition><block-definition s="combs %&apos;r&apos; at a time $!-1-255-255-0 of %&apos;n&apos;" type="reporter" category="operators"><comment x="0" y="0" w="218.66666666666666" collapsed="false">Computes the number of combinations of right-input things taken left-input at a time, otherwise known as the elements of Pascal&apos;s triangle.  This block shares the ! symbol with the monadic factorial function, because the formula for computing this function uses factorials.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><block s="reportIfElse"><block s="reportAnd"><custom-block s="%s ≥ %s"><block var="n"/><l>0</l></custom-block><block s="reportAnd"><custom-block s="%s ≥ %s"><block var="r"/><l>0</l></custom-block><custom-block s="%s ≤ %s"><block var="r"/><block var="n"/></custom-block></block></block><block s="reportQuotient"><custom-block s="factorial $!-1-255-255-0 %n"><block var="n"/></custom-block><block s="reportProduct"><custom-block s="factorial $!-1-255-255-0 %n"><block var="r"/></custom-block><custom-block s="factorial $!-1-255-255-0 %n"><block s="reportDifference"><block var="n"/><block var="r"/></block></custom-block></block></block><l>0</l></block></autolambda><list><l>r</l><l>n</l></list></block></custom-block><list><block var="r"/><block var="n"/></list></block></block></script></block-definition><block-definition s="factorial $!-1-255-255-0 %&apos;n&apos;" type="reporter" category="operators"><comment x="0" y="0" w="172.66666666666666" collapsed="false">The factorial of a positive integer n is the product of the integers from 1 to n.&#xD;&#xD;In real APL, the domain of this function is extended beyond integers to compute the gamma function.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="n"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="factorial $!-1-255-255-0 %n"><l></l></custom-block></autolambda><list></list></block><block var="n"/></block></block></script><script><block s="doReport"><block s="reportIfElse"><custom-block s="zero? %n"><block var="n"/></custom-block><l>1</l><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block><block s="reportNumbers"><l>1</l><block var="n"/></block></custom-block></block></block></script></block></script></block-definition><block-definition s="combine in rows (reduce by column vectors) %&apos;func&apos; $/-1-255-255-0 %&apos;stuff&apos;" type="reporter" category="lists"><comment x="0" y="0" w="288.6666666666667" collapsed="false">This function has two names because there are two ways&#xD;to understand it.&#xD;&#xD;Lisp way:  A matrix is a list of rows.  This block combines the numbers in each row, producing one value for the entire row.&#xD;&#xD;APL way:  A matrix is made of vectors.  This block takes each column as a vector, and does vector arithmetic on the columns, producing one column as the result.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="stuff"/></custom-block><l>1</l></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block var="func"/><l/></custom-block></autolambda><list></list></block><block var="stuff"/></block></block></script><script><block s="doReport"><block s="reportCombine"><block var="stuff"/><block var="func"/></block></block></script></block></script></block-definition><block-definition s="error %&apos;msg&apos;" type="command" category="control"><header></header><code></code><translations>pt:lança o erro _&#xD;</translations><inputs><input type="%txt"></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>msg</l></list><l>throw new Error(msg);</l></block><list><block var="msg"/></list></block></script></block-definition><block-definition s="%&apos;a&apos; scalar %&apos;pred&apos; %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="190" collapsed="false">Acts just like the function selected from&#xD;the pulldown menu, but hyperized, so&#xD;comparing two equal-sized lists reports&#xD;a list of the same length as the inputs,&#xD;with the results of item-by-item comparisons.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s" readonly="true">﹦<options>﹦&#xD;≠&#xD;identical to&#xD;and&#xD;or&#xD;is _ a _?</options></input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><block s="evaluate"><block s="reportListItem"><block s="reportListIndex"><block var="pred"/><block s="reportNewList"><list><l>﹦</l><l>≠</l><l>identical to</l><l>and</l><l>or</l><l>is _ a _?</l></list></block></block><block s="reportNewList"><list><block s="reifyPredicate"><autolambda><block s="reportEquals"><l></l><l></l></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportNot"><block s="reportEquals"><l></l><l></l></block></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportIsIdentical"><l></l><l></l></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportAnd"><l/><l/></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportOr"><l/><l/></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportIsA"><l></l><l></l></block></autolambda><list></list></block></list></block></block><list><block var="a"/><block var="b"/></list></block></autolambda><list><l>a</l><l>b</l></list></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="%&apos;howmany&apos; deal $?-1-255-255-0 %&apos;range&apos;" type="reporter" category="operators"><comment x="0" y="0" w="177.33333333333334" collapsed="false">Report a list with left-input random integers in the range 1 to right-input.&#xD;No number appears more than once&#xD;in the result.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><custom-block s="%n deal helper %l"><block var="howmany"/><block s="reportNumbers"><l>1</l><block var="range"/></block></custom-block></autolambda><list><l>howmany</l><l>range</l></list></block></custom-block><list><block var="howmany"/><block var="range"/></list></block></block></script></block-definition><block-definition s="%&apos;howmany&apos; deal helper %&apos;data&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportEquals"><block var="howmany"/><l>0</l></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doDeclareVariables"><list><l>choice</l></list></block><block s="doSetVar"><l>choice</l><block s="reportListItem"><block s="reportRandom"><l>1</l><block s="reportListLength"><block var="data"/></block></block><block var="data"/></block></block><block s="doReport"><block s="reportCONS"><block var="choice"/><custom-block s="%n deal helper %l"><block s="reportDifference"><block var="howmany"/><l>1</l></block><block s="reportKeep"><block s="reifyPredicate"><autolambda><block s="reportNot"><block s="reportEquals"><l></l><block var="choice"/></block></block></autolambda><list></list></block><block var="data"/></block></custom-block></block></block></script></block-definition><block-definition s="signum $×-1-255-255-0 %&apos;num&apos;" type="reporter" category="operators"><comment x="0" y="0" w="159.99999999999997" collapsed="false">Reports 1 if the input is positive,&#xD;0 if the input is zero,&#xD;or -1 if the input is negative.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="num"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="signum $×-1-255-255-0 %n"><l></l></custom-block></autolambda><list></list></block><block var="num"/></block></block></script></block><block s="doIf"><block s="reportListContainsItem"><block s="reportNewList"><list><l>0</l><block s="reportBoolean"><l><bool>false</bool></l></block></list></block><block var="num"/></block><script><block s="doReport"><l>0</l></block></script></block><block s="doReport"><block s="reportQuotient"><block var="num"/><block s="reportMonadic"><l><option>abs</option></l><block var="num"/></block></block></block></script></block-definition><block-definition s="reciprocal $÷-1-255-255-0 %&apos;num&apos;" type="reporter" category="operators"><comment x="0" y="0" w="102.66666666666667" collapsed="false">reports 1 divided&#xD;by its input.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doReport"><block s="reportQuotient"><l>1</l><block var="num"/></block></block></script></block-definition><block-definition s="roll $?-1-255-255-0 %&apos;num&apos;" type="reporter" category="operators"><comment x="0" y="0" w="180.66666666666666" collapsed="false">This block reports a random integer between 1 and its input.  To roll more than one die, use (for three dice)&#xD;roll (reshape as 3 items of 6)&#xD;APL:  ?3⍴6&#xD;Don&apos;t use reshape as 3 items of roll 6, because that would roll one die and report 3 copies of the same random roll. </comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doReport"><block s="reportRandom"><l>1</l><block var="num"/></block></block></script></block-definition><block-definition s="GCD (or) %&apos;a&apos; $∨-1.2-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="230.66666666666666" collapsed="false">Reports the greatest common divisor of its inputs.&#xD;If the inputs are values in {0,1} then this is equivalent to the logical OR of the values, with 0=False, 1=True.  Hence the APL symbol ∨.&#xD;Also accepts Snap! Booleans as inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><script><block s="doIf"><block s="reportListContainsItem"><block s="reportNewList"><list><l>0</l><block s="reportBoolean"><l><bool>false</bool></l></block></list></block><block var="b"/></block><script><block s="doReport"><block var="a"/></block></script></block><block s="doReport"><custom-block s="GCD (or) %n $∨-1.2-255-255-0 %n"><block var="b"/><block s="reportModulus"><block var="a"/><block var="b"/></block></custom-block></block></script><list><l>a</l><l>b</l></list></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="scalar -&gt; hyper %&apos;func&apos;" type="reporter" category="control"><comment x="0" y="0" w="218" collapsed="false">Takes a dyadic scalar function as input, and&#xD;hyperizes it, so that it can take lists as inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input></inputs><script><block s="doDeclareVariables"><list><l>hyper func</l></list></block><block s="doSetVar"><l>hyper func</l><block s="reifyReporter"><script><block s="doIfElse"><custom-block s="scalar? %s"><block var="a"/></custom-block><script><block s="doIfElse"><custom-block s="scalar? %s"><block var="b"/></custom-block><script><block s="doReport"><block s="evaluate"><block var="func"/><list><custom-block s="scalar-value helper %s"><block var="a"/></custom-block><custom-block s="scalar-value helper %s"><block var="b"/></custom-block></list></block></block></script><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="hyper func"/><list><custom-block s="scalar-value helper %s"><block var="a"/></custom-block><l></l></list></block></autolambda><list></list></block><block var="b"/></block></block></script></block></script><script><block s="doIfElse"><custom-block s="scalar? %s"><block var="b"/></custom-block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="hyper func"/><list><l></l><custom-block s="scalar-value helper %s"><block var="b"/></custom-block></list></block></autolambda><list></list></block><block var="a"/></block></block></script><script><block s="doReport"><custom-block s="multimap %repRing %mult%l"><block var="hyper func"/><list><block var="a"/><block var="b"/></list></custom-block></block></script></block></script></block></script><list><l>a</l><l>b</l></list></block></block><block s="doReport"><block var="hyper func"/></block></script></block-definition><block-definition s="scalar? %&apos;x&apos;" type="predicate" category="other"><comment x="0" y="0" w="199.33333333333334" collapsed="false">Reports True if the input is an APL scalar,&#xD;i.e., either an atomic (non-list) value, or&#xD;an array (list of lists) of any depth with only&#xD;one atomic item, e.g., (list (list (list (3)))).</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="x"/><l><option>list</option></l></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doReport"><block s="reportEquals"><block s="reportCombine"><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="x"/></custom-block><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block></block><l>1</l></block></block></script></block-definition><block-definition s="scalar-value helper %&apos;x&apos;" type="reporter" category="other"><comment x="0" y="0" w="200.66666666666666" collapsed="false">The input must be a value for which SCALAR? reports true, i.e., either an atom or a list of any depth but only one scalar item of item of... etc.  This function returns the underlying scalar (number, etc.).</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="x"/><l><option>list</option></l></block></block><script><block s="doReport"><block var="x"/></block></script></block><block s="doReport"><custom-block s="scalar-value helper %s"><block s="reportListItem"><l>1</l><block var="x"/></block></custom-block></block></script></block-definition><block-definition s="LCM (and) %&apos;a&apos; $∧-1.2-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="230.66666666666666" collapsed="false">Reports the least common multiple of its inputs.&#xD;If the inputs are values in {0,1} then this is equivalent to the logical AND of the values, with 0=False, 1=True.  Hence the APL symbol ∧.&#xD;Also accepts Snap! Booleans as inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><script><block s="doIf"><block s="reportListContainsItem"><block s="reportNewList"><list><l>0</l><block s="reportBoolean"><l><bool>false</bool></l></block></list></block><block var="b"/></block><script><block s="doReport"><block var="b"/></block></script></block><block s="doReport"><block s="reportProduct"><block var="a"/><block s="reportQuotient"><block var="b"/><custom-block s="GCD (or) %n $∨-1.2-255-255-0 %n"><block var="a"/><block var="b"/></custom-block></block></block></block></script><list><l>a</l><l>b</l></list></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="NAND %&apos;a&apos; $⍲-1.4-255-255-0 %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="198.66666666666666" collapsed="false">Reports the not-and of its inputs, in the form&#xD;0 for false, 1 for true.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="NOT $&#126;-1-255-255-0 %s"><custom-block s="LCM (and) %n $∧-1.2-255-255-0 %n"><block var="a"/><block var="b"/></custom-block></custom-block></block></script></block-definition><block-definition s="NOT $&#126;-1-255-255-0 %&apos;p&apos;" type="reporter" category="operators"><comment x="0" y="0" w="167.33333333333334" collapsed="false">Reports 1 if the input is False or 0;&#xD;otherwise reports 0.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="reportDifference"><l>1</l><custom-block s="signum $×-1-255-255-0 %n"><block var="p"/></custom-block></block></block></script></block-definition><block-definition s="NOR %&apos;a&apos; $⍱-1.4-255-255-0 %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="198.66666666666666" collapsed="false">Reports the not-and of its inputs, in the form&#xD;0 for false, 1 for true.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="NOT $&#126;-1-255-255-0 %s"><custom-block s="GCD (or) %n $∨-1.2-255-255-0 %n"><block var="a"/><block var="b"/></custom-block></custom-block></block></script></block-definition><block-definition s="%&apos;a&apos; ≤ %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="151.33333333333334" collapsed="false">Reports True if the left input is&#xD;less than or equal to the right input.&#xD;&#xD;Reports a Snap! Boolean, not an integer 0 or 1.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="truth %s"><custom-block s="NOT $&#126;-1-255-255-0 %s"><block s="reportGreaterThan"><block var="a"/><block var="b"/></block></custom-block></custom-block></block></script></block-definition><block-definition s="%&apos;a&apos; ≥ %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="152.66666666666666" collapsed="false">Reports True if the left input is&#xD;greater than than or equal to&#xD;the right input.&#xD;&#xD;Reports a Snap! Boolean, not an integer 0 or 1.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="truth %s"><custom-block s="NOT $&#126;-1-255-255-0 %s"><block s="reportLessThan"><block var="a"/><block var="b"/></block></custom-block></custom-block></block></script></block-definition><block-definition s="XOR %&apos;a&apos; $≠-1-255-255-0 %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="190" collapsed="false">Reports 0 if its inputs are equal;&#xD;reports 1 if its inputs are not equal.&#xD;The inputs can have any non-list values.&#xD;(Lists are hyperized.)  If the inputs are&#xD;Booleans (True/False or 1/0), this is&#xD;also the exclusive-or function.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="%s scalar %s %s"><block var="a"/><l>≠</l><block var="b"/></custom-block></block></script></block-definition><block-definition s="zero? %&apos;n&apos;" type="predicate" category="other"><comment x="0" y="0" w="202.66666666666666" collapsed="true">reports True iff the input is 0 or False.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doReport"><block s="reportListContainsItem"><block s="reportNewList"><list><l>0</l><block s="reportBoolean"><l><bool>false</bool></l></block></list></block><block var="n"/></block></block></script></block-definition><block-definition s="truth %&apos;n&apos;" type="predicate" category="other"><comment x="0" y="0" w="198.66666666666666" collapsed="false">Reports a Snap! Boolean False if the input&#xD;is False or 0; reports True otherwise.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="reportIfElse"><block s="reportIsA"><block var="n"/><l><option>Boolean</option></l></block><block var="n"/><block s="reportNot"><block s="reportEquals"><block var="n"/><l>0</l></block></block></block></block></script></block-definition><block-definition s="make scalar %&apos;value&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><custom-block s="scalar? %s"><block var="value"/></custom-block><script><block s="doReport"><custom-block s="scalar-value helper %s"><block var="value"/></custom-block></block></script></block><custom-block s="error %txt"><block s="reportJoinWords"><list><l>Make scalar called with non-singleton input </l><block var="value"/></list></block></custom-block></script></block-definition><block-definition s="$⍳-1.5-255-255-0 %&apos;n&apos;" type="reporter" category="lists"><comment w="290.6666666666667" collapsed="false">If the input is a positive integer, reports a list of the numbers&#xD;from 1 to that input.  (If the input is 0, reports an empty list.)&#xD;&#xD;If the input is a list of positive integers, reports an array with&#xD;the shape specified by the input (as in ⍴ reshape) in which&#xD;each item is a list of the indices of that item in the array&#xD;(so technically the shape has one more dimension&#xD;than the input, whose size is the size of the input).</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="n"/><l><option>list</option></l></block><script><block s="doIfElse"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="n"/></custom-block><l>1</l></block><script><block s="doIfElse"><custom-block s="zero? %n"><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block><block var="n"/></custom-block></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doReport"><custom-block s="reshape helper %l %l"><block var="n"/><custom-block s="crossproduct %mult%l"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="$⍳-1.5-255-255-0 %n"><l></l></custom-block></autolambda><list></list></block><block var="n"/></block></custom-block></custom-block></block></script></block></script><script><custom-block s="error %txt"><l>Input to ⍳ can&apos;t be a list of lists.</l></custom-block></script></block></script><script><block s="doReport"><block s="reportIfElse"><custom-block s="zero? %n"><block var="n"/></custom-block><block s="reportNewList"><list></list></block><block s="reportNumbers"><l>1</l><block var="n"/></block></block></block></script></block></script></block-definition><block-definition s="where in %&apos;vector&apos; is $⍳-1.5-255-255-0 %&apos;items&apos;" type="reporter" category="lists"><comment x="0" y="0" w="334.6666666666667" collapsed="false">If the rank of the left input is one more than the rank of the right input,&#xD;reports the index of the right input in the left input, or if not found,&#xD;reports one more than the length of the left input.&#xD;&#xD;If the rank of the left input is equal to the rank of the right input,&#xD;reports a vector of the indices of the items of the right input&#xD;in the left input (mapping this function over the right input).&#xD;&#xD;If the rank of the left input is more than that of the right input by 2 or more,&#xD;reports a vector, the location of the right input in the left in each dimension.&#xD;&#xD;It is an error if the rank of the left input is less than that of the right input.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>result</l></list></block><block s="doIf"><block s="reportLessThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vector"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="items"/></custom-block></block><script><custom-block s="error %txt"><l>Left input to ⍳ must have greater or equal rank to right input.</l></custom-block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vector"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="items"/></custom-block></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="where in %l is $⍳-1.5-255-255-0 %s"><block var="vector"/><l></l></custom-block></autolambda><list></list></block><block var="items"/></block></block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vector"/></custom-block><block s="reportSum"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="items"/></custom-block><l>1</l></block></block><script><block s="doSetVar"><l>result</l><block s="reportListIndex"><block var="items"/><block var="vector"/></block></block><block s="doReport"><block s="reportIfElse"><custom-block s="zero? %n"><block var="result"/></custom-block><block s="reportSum"><block s="reportListLength"><block var="vector"/></block><l>1</l></block><block var="result"/></block></block></script></block><block s="doSetVar"><l>result</l><block s="reportFindFirst"><block s="reifyPredicate"><autolambda><custom-block s="%l deep contains %s"><l/><block var="items"/></custom-block></autolambda><list></list></block><block var="vector"/></block></block><block s="doIf"><block s="reportEquals"><block var="result"/><l></l></block><script><block s="doReport"><block s="reportSum"><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="vector"/></custom-block><l>1</l></block></block></script></block><block s="doReport"><block s="reportCONS"><block s="reportListIndex"><block var="result"/><block var="vector"/></block><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><custom-block s="where in %l is $⍳-1.5-255-255-0 %s"><block var="result"/><block var="items"/></custom-block></custom-block></block></block></script></block-definition><block-definition s="crossproduct %&apos;lists&apos;" type="reporter" category="lists"><comment x="0" y="0" w="305.3333333333333" collapsed="false">This isn&apos;t an APL function, although it&apos;s related to the outer product.&#xD;&#xD;It takes any number of lists, and reports a list of all possible tuples with one item from each of the lists.  The length of the result is the product of the lengths of the inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%mult%l"></input></inputs><script><block s="doIfElse"><block s="reportListIsEmpty"><block var="lists"/></block><script><block s="doReport"><block s="reportNewList"><list><block s="reportNewList"><list></list></block></list></block></block></script><script><block s="doDeclareVariables"><list><l>small</l></list></block><block s="doSetVar"><l>small</l><custom-block s="crossproduct %mult%l"><block s="reportCDR"><block var="lists"/></block></custom-block></block><block s="doReport"><block s="reportConcatenatedLists"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportCONS"><block var="newitem"/><l/></block></autolambda><list></list></block><block var="small"/></block></autolambda><list><l>newitem</l></list></block><block s="reportListItem"><l>1</l><block var="lists"/></block></block></block></block></script></block></script></block-definition><block-definition s="%&apos;array&apos; deep contains %&apos;value&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="array"/><l><option>list</option></l></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>false</bool></l></block></block></script></block><block s="doIf"><block s="reportListContainsItem"><block var="array"/><block var="value"/></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doReport"><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block s="reifyReporter"><autolambda><block s="reportOr"><l/><l/></block></autolambda><list></list></block><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="%l deep contains %s"><l/><block var="value"/></custom-block></autolambda><list></list></block><block var="array"/></block></custom-block></block></script></block-definition><block-definition s="which of %&apos;items&apos; $ϵ-1-255-255-0 contained in %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="214.66666666666666" collapsed="false">Reports an array of Booleans the same shape&#xD;as the left input, indicating which of the atoms&#xD;in the left input appear anywhere in the right&#xD;input.  &#xD;(The structure of the right input doesn&apos;t matter.)</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="items"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="which of %s $ϵ-1-255-255-0 contained in %l"><l></l><block var="array"/></custom-block></autolambda><list></list></block><block var="items"/></block></block></script><script><block s="doReport"><block s="reportListContainsItem"><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><block var="array"/></custom-block><block var="items"/></block></block></script></block></script></block-definition><block-definition s="catenate %&apos;left&apos; $,-1-255-255-0 %&apos;right&apos;" type="reporter" category="lists"><comment w="190.66666666666666" collapsed="false">Like append, but:&#xD;&#xD;A scalar input is treated as an array the same shape as the other input except that the last item of the shape is 1.&#xD;&#xD;If the two inputs are of different ranks,&#xD;the function is mapped over the larger ranked input.&#xD;&#xD;Catenate adds new columns, by appending to each row.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="left"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>left</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>-1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="right"/></custom-block></custom-block><block s="reportNewList"><list><l>1</l></list></block></list></block><block s="reportNewList"><list><block var="left"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>left</l><block s="reportNewList"><list><block var="left"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="right"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>right</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>-1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="left"/></custom-block></custom-block><block s="reportNewList"><list><l>1</l></list></block></list></block><block s="reportNewList"><list><block var="right"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>right</l><block s="reportNewList"><list><block var="right"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doIfElse"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doReport"><block s="reportConcatenatedLists"><list><block var="left"/><block var="right"/></list></block></block></script><script><block s="doReport"><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block><list><block var="left"/><block var="right"/></list></custom-block></block></script></block></script></block><block s="doIfElse"><block s="reportLessThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><block var="left"/><l></l></custom-block></autolambda><list></list></block><block var="right"/></block></block></script><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><block var="right"/></custom-block></autolambda><list></list></block><block var="left"/></block></block></script></block></script></block-definition><block-definition s="scalar value %&apos;value&apos;" type="reporter" category="lists"><comment x="0" y="0" w="221.33333333333334" collapsed="false">If the input is a nesting of length=1 lists, which&#xD;APL treats as a scalar (the innermost item)&#xD;for many purposes, report that innermost scalar.&#xD;Otherwise, report the input as is.&#xD;&#xD;Exposing this block for users is important because Snap! /does not/ treat such a nesting&#xD;as a scalar, so you might need to use this in&#xD;translating an APL program to Snap!.&#xD;(But the functions in the APL library already use&#xD;this block as needed.)</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="reportIfElse"><custom-block s="scalar? %s"><block var="value"/></custom-block><custom-block s="scalar-value helper %s"><block var="value"/></custom-block><block var="value"/></block></block></script></block-definition><block-definition s="grade up $⍋-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="190.66666666666666" collapsed="false">Reports a vector of indices of the items of the input, in order of the values of the items, so that&#xD;&#xD;item (grade up (foo)) of (foo)&#xD;&#xD;reports the items in sorted order, smallest to largest.  For a matrix, sorts the rows based on their first items, or if those are equal, based on their second items, etc.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l><option>last</option></l><l/></block></autolambda><list></list></block><custom-block s="sort %l ordering with %predRing"><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block><list><block var="array"/><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportListLength"><block var="array"/></block></custom-block></list></custom-block><block s="reifyPredicate"><autolambda><custom-block s="sort helper %l %l"><l/><l/></custom-block></autolambda><list></list></block></custom-block></block></block></script></block-definition><block-definition s="sort %&apos;data&apos; ordering with %&apos;function&apos;" type="reporter" category="other"><comment x="0" y="0" w="161.14285714285708" collapsed="false">Reports a sorted version of the list in its first input slot, using the comparison function in the second input slot.  For a list of numbers, using &lt; as the comparison function will sort from low to high; using &gt; will sort from high to low.</comment><header></header><code></code><translations>ca:ordena _ segons criteri _&#xD;</translations><inputs><input type="%l"></input><input type="%predRing"></input></inputs><script><block s="doDeclareVariables"><list><l>even items</l><l>odd items</l><l>merge</l><l>split</l><l>copy of data</l><l>id</l></list></block><block s="doSetVar"><l>id</l><block s="reifyScript"><script><block s="doReport"><l></l></block></script><list></list></block></block><block s="doSetVar"><l>copy of data</l><block s="reportMap"><block var="id"/><block var="data"/></block></block><block s="doSetVar"><l>split</l><block s="reifyScript"><script><block s="doSetVar"><l>even items</l><block s="reportNewList"><list></list></block></block><block s="doSetVar"><l>odd items</l><block s="reportNewList"><list></list></block></block><block s="doUntil"><block s="reportListIsEmpty"><block var="copy of data"/></block><script><block s="doAddToList"><block s="reportListItem"><l>1</l><block var="copy of data"/></block><block var="odd items"/></block><block s="doDeleteFromList"><l>1</l><block var="copy of data"/></block><block s="doIf"><block s="reportNot"><block s="reportListIsEmpty"><block var="copy of data"/></block></block><script><block s="doAddToList"><block s="reportListItem"><l>1</l><block var="copy of data"/></block><block var="even items"/></block><block s="doDeleteFromList"><l>1</l><block var="copy of data"/></block></script></block></script></block></script><list></list></block></block><block s="doSetVar"><l>merge</l><block s="reifyScript"><script><block s="doIf"><block s="reportEquals"><block var="#1"/><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block var="#2"/></block></script></block><block s="doIf"><block s="reportEquals"><block var="#2"/><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block var="#1"/></block></script></block><block s="doIfElse"><block s="evaluate"><block var="function"/><list><block s="reportListItem"><l>1</l><block var="#1"/></block><block s="reportListItem"><l>1</l><block var="#2"/></block></list></block><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="#1"/></block><block s="evaluate"><block var="merge"/><list><block s="reportCDR"><block var="#1"/></block><block var="#2"/></list></block></block></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="#2"/></block><block s="evaluate"><block var="merge"/><list><block var="#1"/><block s="reportCDR"><block var="#2"/></block></list></block></block></block></script></block></script><list><l>#1</l><l>#2</l></list></block></block><block s="doIf"><block s="reportEquals"><block var="data"/><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doIf"><block s="reportEquals"><block s="reportCDR"><block var="data"/></block><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block var="data"/></block></script></block><block s="doRun"><block var="split"/><list></list></block><block s="doReport"><block s="evaluate"><block var="merge"/><list><custom-block s="sort %l ordering with %predRing"><block var="odd items"/><block var="function"/></custom-block><custom-block s="sort %l ordering with %predRing"><block var="even items"/><block var="function"/></custom-block></list></block></block></script></block-definition><block-definition s="sort helper %&apos;rowA&apos; %&apos;rowB&apos;" type="reporter" category="other"><comment x="0" y="0" w="166" collapsed="false">Compares two vectors for sorting.&#xD;Compare first items; if those are equal compare second items; etc.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="rowA"/></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doIf"><block s="reportListIsEmpty"><block var="rowB"/></block><script><block s="doReport"><block s="reportBoolean"><l><bool>false</bool></l></block></block></script></block><block s="doIf"><block s="reportLessThan"><block s="reportListItem"><l>1</l><block var="rowA"/></block><block s="reportListItem"><l>1</l><block var="rowB"/></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doIf"><block s="reportGreaterThan"><block s="reportListItem"><l>1</l><block var="rowA"/></block><block s="reportListItem"><l>1</l><block var="rowB"/></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>false</bool></l></block></block></script></block><block s="doReport"><custom-block s="sort helper %l %l"><block s="reportCDR"><block var="rowA"/></block><block s="reportCDR"><block var="rowB"/></block></custom-block></block></script></block-definition><block-definition s="grade down $⍒-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="190.66666666666666" collapsed="false">Reports a vector of indices of the items of the input, in order of the values of the items, so that&#xD;&#xD;item (grade down (foo)) of (foo)&#xD;&#xD;reports the items in sorted order, largest to smallest.  For a matrix, sorts the rows based on their first items, or if those are equal, based on their second items, etc.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l><option>last</option></l><l/></block></autolambda><list></list></block><custom-block s="sort %l ordering with %predRing"><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block><list><block var="array"/><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportListLength"><block var="array"/></block></custom-block></list></custom-block><block s="reifyPredicate"><autolambda><custom-block s="NOT $&#126;-1-255-255-0 %s"><custom-block s="sort helper %l %l"><l/><l/></custom-block></custom-block></autolambda><list></list></block></custom-block></block></block></script></block-definition><block-definition s="select rows (compress columns) %&apos;Booleans&apos; $/-1-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment w="210.66666666666666" collapsed="false">The left input must be a vector of Booleans&#xD;(either Snap! form or APL form); the right input must be an array whose first dimension is equal to the length of the left input.  The block reports an array of the same rank as the right input, containing only those items (rows, for a matrix) for which the corresponding Boolean is True (or 1).</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="rowize vector %l"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportCDR"><l/></block></autolambda><list></list></block><block s="reportKeep"><block s="reifyPredicate"><autolambda><custom-block s="truth %s"><block s="reportListItem"><l>1</l><l/></block></custom-block></autolambda><list></list></block><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block><list><block var="Booleans"/><block var="array"/></list></custom-block></block></block></custom-block></block></script></block-definition><block-definition s="rowize vector %&apos;vec&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportIfElse"><block s="reportAnd"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vec"/></custom-block><l>2</l></block><block s="reportEquals"><block s="reportListItem"><l>2</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="vec"/></custom-block></block><l>1</l></block></block><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l>1</l><l/></block></autolambda><list></list></block><block var="vec"/></block><block var="vec"/></block></block></script></block-definition><block-definition s="select columns (compress rows) %&apos;bool&apos; $⌿-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="219.33333333333334" collapsed="false">The left input must be a vector of Booleans&#xD;(either Snap! form or APL form); the right input must be an array whose last dimension is equal to the length of the left input.  The block reports an array of the same rank as the right input, containing only those items (columns, for a matrix) for which the corresponding Boolean is True (or 1).</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="columnwise %repRing %l"><block s="reifyReporter"><autolambda><custom-block s="select rows (compress columns) %l $/-1-255-255-0 %l"><block var="bool"/><l/></custom-block></autolambda><list></list></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="columnwise %&apos;function&apos; %&apos;data&apos;" type="reporter" category="control"><comment w="212" collapsed="false">Turns a row-wise (in Lisp terminology) function&#xD;into a column-wise one.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="rowize vector %l"><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block s="evaluate"><block var="function"/><list><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="data"/></custom-block></list></block></custom-block></custom-block></block></script></block-definition><block-definition s="reverse column order (row contents) $⏀-1-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="206" collapsed="false">Reverses the order of the columns of the input, which is a reflection through a vertical axis, as the ⏀ symbol suggests.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="columnwise %repRing %l"><block s="reifyReporter"><autolambda><custom-block s="reverse row order (column contents) $⦵-1.5-255-255-0 %l"><l/></custom-block></autolambda><list></list></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="combine in columns (reduce by row vectors) %&apos;function&apos; $⌿-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="285.3333333333333" collapsed="false">This function has two names because there are two ways&#xD;to understand it.&#xD;&#xD;Lisp way:  A matrix is a list of rows.  This block turns it into a list of columns, and combines the numbers in each column, producing one value for the entire column.&#xD;&#xD;APL way:  A matrix is made of vectors.  This block takes each row as a vector, and does vector arithmetic on the rows, producing one row as the result.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="columnwise %repRing %l"><block s="reifyReporter"><autolambda><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block var="function"/><l/></custom-block></autolambda><list></list></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="catenate vertically %&apos;left&apos; $⍪-1.5-255-255-0 %&apos;right&apos;" type="reporter" category="lists"><comment w="190.66666666666666" collapsed="false">Like append, but:&#xD;&#xD;A scalar input is treated as a vector&#xD;of length 1.&#xD;&#xD;If the two inputs are of different ranks,&#xD;the function is mapped over the larger ranked input.&#xD;&#xD;Catenate vertically adds new rows, by appending to each column.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="left"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>left</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><block s="reportNewList"><list><l>1</l></list></block><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="right"/></custom-block></custom-block></list></block><block s="reportNewList"><list><block var="left"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>left</l><block s="reportNewList"><list><block var="left"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="right"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>right</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><block s="reportNewList"><list><l>1</l></list></block><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="left"/></custom-block></custom-block></list></block><block s="reportNewList"><list><block var="right"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>right</l><block s="reportNewList"><list><block var="right"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doIfElse"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doReport"><block s="reportConcatenatedLists"><list><block var="left"/><block var="right"/></list></block></block></script><script><block s="doReport"><custom-block s="transpose $⍉-1.5-255-255-0 %l"><custom-block s="catenate %s $,-1-255-255-0 %s"><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="left"/></custom-block><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="right"/></custom-block></custom-block></custom-block></block></script></block></script></block><block s="doIfElse"><block s="reportLessThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><block var="left"/><l></l></custom-block></autolambda><list></list></block><block var="right"/></block></block></script><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><block var="right"/></custom-block></autolambda><list></list></block><block var="left"/></block></block></script></block></script><scripts><script x="254" y="497.7777777777774"><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><script></script><list></list></block><list><l/><l/></list></custom-block></script></scripts></block-definition><block-definition s="%&apos;a&apos; scalar join %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="219.33333333333334" collapsed="false">A hyperblock version of JOIN.  The regular JOIN isn&apos;t hyperized because it can accept a list as input, representing it as text.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><block s="reportJoinWords"><list><l></l><l></l></list></block></autolambda><list></list></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="take %&apos;howmany&apos; $↑-1-255-255-0 from %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="272" collapsed="false">A positive left input selects the first n items of the right input.&#xD;A negative left input selects the last abs(n) items&#xD;of the right input.&#xD;&#xD;If the right input is a matrix, a numeric left input selects rows;&#xD;the left input may also be a two-item vector, in which case&#xD;the first number is applied to the rows&#xD;and the second number is applied to the columns.&#xD;Similarly for higher-dimension arrays. </comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="howmany"/><l><option>number</option></l></block><script><block s="doReport"><block s="reportIfElse"><block s="reportLessThan"><block var="howmany"/><l>0</l></block><block s="reportListItem"><block s="reportSum"><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportMonadic"><l><option>abs</option></l><block var="howmany"/></block></custom-block><block s="reportSum"><block s="reportListLength"><block var="array"/></block><block var="howmany"/></block></block><block var="array"/></block><block s="reportListItem"><custom-block s="$⍳-1.5-255-255-0 %n"><block var="howmany"/></custom-block><block var="array"/></block></block></block></script></block><block s="doIf"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="howmany"/></custom-block><l>1</l></block><script><custom-block s="error %txt"><l>Left input to take can&apos;t be a matrix.</l></custom-block></script></block><block s="doIf"><block s="reportGreaterThan"><block s="reportListLength"><block var="howmany"/></block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="array"/></custom-block></block><script><custom-block s="error %txt"><l>Length of item vector &gt; rank of array in take.</l></custom-block></script></block><block s="doReport"><block s="reportListItem"><custom-block s="reverse row order (column contents) $⦵-1.5-255-255-0 %l"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportIfElse"><block s="reportLessThan"><block var="value"/><l>0</l></block><block s="reportSum"><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportMonadic"><l><option>abs</option></l><block var="value"/></block></custom-block><block s="reportSum"><block s="reportListItem"><block var="index"/><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></block><block var="value"/></block></block><custom-block s="$⍳-1.5-255-255-0 %n"><block var="value"/></custom-block></block></autolambda><list><l>value</l><l>index</l></list></block><block var="howmany"/></block></custom-block><block var="array"/></block></block></script></block-definition><block-definition s="drop %&apos;howmany&apos; $↓-1-255-255-0 from %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="306" collapsed="false">A positive left input selects all but the first n items of the right input.&#xD;A negative left input selects all but the last abs(n) items&#xD;of the right input.&#xD;&#xD;If the right input is a matrix, a numeric left input selects rows;&#xD;the left input may also be a two-item vector, in which case&#xD;the first number is applied to the rows&#xD;and the second number is applied to the columns.&#xD;Similarly for higher-dimension arrays. </comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="howmany"/><l><option>number</option></l></block><script><block s="doReport"><custom-block s="take %n $↑-1-255-255-0 from %l"><block s="reportProduct"><block s="reportMonadic"><l><option>neg</option></l><custom-block s="signum $×-1-255-255-0 %n"><block var="howmany"/></custom-block></block><block s="reportDifference"><block s="reportListLength"><block var="array"/></block><block s="reportMonadic"><l><option>abs</option></l><block var="howmany"/></block></block></block><block var="array"/></custom-block></block></script></block><block s="doReport"><custom-block s="take %n $↑-1-255-255-0 from %l"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportIfElse"><block s="reportLessThan"><block var="value"/><l>0</l></block><block s="reportSum"><block s="reportListItem"><block var="index"/><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></block><block var="value"/></block><block s="reportDifference"><block var="value"/><block s="reportListItem"><block var="index"/><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></block></block></block></autolambda><list><l>value</l><l>index</l></list></block><block var="howmany"/></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="%&apos;x&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block var="x"/></block></script></block-definition><block-definition s="reshape helper %&apos;shape&apos; %&apos;data&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="shape"/></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doIf"><block s="reportEquals"><block s="reportCombine"><block var="shape"/><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block></block><l>0</l></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doDeclareVariables"><list><l>partial</l></list></block><block s="doSetVar"><l>partial</l><block s="reportNewList"><list></list></block></block><block s="doIfElse"><block s="reportListIsEmpty"><block s="reportCDR"><block var="shape"/></block></block><script><block s="doRepeat"><block s="reportListItem"><l>1</l><block var="shape"/></block><script><block s="doAddToList"><block s="reportListItem"><l>1</l><block var="data"/></block><block var="partial"/></block><block s="doSetVar"><l>data</l><block s="reportConcatenatedLists"><list><block s="reportCDR"><block var="data"/></block><block s="reportNewList"><list><block s="reportListItem"><l>1</l><block var="data"/></block></list></block></list></block></block></script></block></script><script><block s="doRepeat"><block s="reportListItem"><l>1</l><block var="shape"/></block><script><block s="doAddToList"><custom-block s="reshape helper %l %l"><block s="reportCDR"><block var="shape"/></block><block var="data"/></custom-block><block var="partial"/></block><block s="doRepeat"><block s="reportModulus"><block s="reportCombine"><block s="reportCDR"><block var="shape"/></block><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block></block><block s="reportListLength"><block var="data"/></block></block><script><block s="doSetVar"><l>data</l><block s="reportConcatenatedLists"><list><block s="reportCDR"><block var="data"/></block><block s="reportNewList"><list><block s="reportListItem"><l>1</l><block var="data"/></block></list></block></list></block></block></script></block></script></block></script></block><block s="doReport"><block var="partial"/></block></script></block-definition><block-definition s="deep map %&apos;function&apos; %&apos;atom?&apos; %&apos;data&apos;" type="reporter" category="other"><comment w="320.6666666666667" collapsed="false">Applies the function to each &quot;atom&quot; of the data.  What&apos;s an atom?&#xD;Something for which the predicate input reports true.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%predRing"></input><input type="%l"></input></inputs><script><block s="doIf"><custom-block s="truth %s"><block s="evaluate"><block var="atom?"/><list><block var="data"/></list></block></custom-block><script><block s="doReport"><block s="evaluate"><block var="function"/><list><block var="data"/></list></block></block></script></block><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="deep map %repRing %predRing %l"><block var="function"/><block var="atom?"/><l/></custom-block></autolambda><list></list></block><block var="data"/></block></block></script></block-definition><block-definition s="nth item 1 %&apos;n&apos; %&apos;data&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportEquals"><block var="n"/><l>0</l></block><script><block s="doReport"><block var="data"/></block></script></block><block s="doReport"><custom-block s="nth item 1 %n %l"><block s="reportDifference"><block var="n"/><l>1</l></block><block s="reportListItem"><l>1</l><block var="data"/></block></custom-block></block></script></block-definition></blocks>