<blocks app="Snap! 6, https://snap.berkeley.edu" version="1"><block-definition s="reshape as %&apos;shape&apos; $⍴-1-255-255-0 items of %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="180" collapsed="false">The first input is a shape list as in&#xD;SHAPE OF.  The output is an array with those dimensions containing  the atomic items of the second input,&#xD;repeating values if more are needed.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doReport"><block s="reportReshape"><block var="data"/><block var="shape"/></block></block></script></block-definition><block-definition s="shape of $⍴-1-255-255-0 %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="310" collapsed="false">Reports a flat list of the maximum size of the input array along&#xD;each dimension: number of rows, number of columns, etc.&#xD;&quot;Maximum&quot; because it works even if the array isn&apos;t uniformly shaped.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportListAttribute"><l><option>dimensions</option></l><block var="data"/></block></block></script></block-definition><block-definition s="max %&apos;a&apos; $⌈-1-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="150.66666666666666" collapsed="false">Reports the greater of its two inputs. Works on strings too.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="reportMax"><block var="a"/><block var="b"/></block></block></script></block-definition><block-definition s="flatten (ravel) $,-1-255-255-0 %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="216" collapsed="false">Reports a flat list of all the atomic elements &#xD;of sublists of the input list.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportListAttribute"><l><option>flatten</option></l><block var="data"/></block></block></script></block-definition><block-definition s="outer product %&apos;a&apos; $○.-1-255-255-0 %&apos;function&apos; %&apos;b&apos;" type="reporter" category="lists"><comment x="0" y="0" w="297.99999999999994" collapsed="false">Given two arrays A and B, reports an array whose dimensions are&#xD;APPEND(SHAPE OF (A), SHAPE OF (B))&#xD;in which each atomic item of the result is computed by applying the dyadic function input to an item of A and an item of B.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="a"/><l><option>list</option></l></block><script><block s="doIf"><block s="reportListIsEmpty"><block var="a"/></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doReport"><block s="reportCONS"><custom-block s="outer product %l $○.-1-255-255-0 %repRing %l"><block s="reportListItem"><l>1</l><block var="a"/></block><block var="function"/><block var="b"/></custom-block><custom-block s="outer product %l $○.-1-255-255-0 %repRing %l"><block s="reportCDR"><block var="a"/></block><block var="function"/><block var="b"/></custom-block></block></block></script><script><block s="doReport"><block s="evaluate"><block var="function"/><list><block var="a"/><block var="b"/></list></block></block></script></block></script></block-definition><block-definition s="rank of $⍴⍴-1-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="240" collapsed="true">Reports the number of dimensions of the input.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportListAttribute"><l><option>rank</option></l><block var="array"/></block></block></script></block-definition><block-definition s="inner product helper with %&apos;plus&apos; . %&apos;times&apos; %&apos;a&apos; $nl transposed %&apos;tb&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%repRing"></input><input type="%l"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="a"/></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block s="reportListItem"><l>1</l><block s="reportListItem"><l>1</l><block var="a"/></block></block><l><option>list</option></l></block></block><script><block s="doReport"><block s="reportCONS"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="generalized dotproduct %l %l with sum %repRing product %repRing"><block s="reportListItem"><l>1</l><block var="a"/></block><l/><block var="plus"/><block var="times"/></custom-block></autolambda><list></list></block><block var="tb"/></block><custom-block s="inner product helper with %repRing . %repRing %l %br transposed %l"><block var="plus"/><block var="times"/><block s="reportCDR"><block var="a"/></block><block var="tb"/></custom-block></block></block></script></block><block s="doReport"><block s="reportCONS"><custom-block s="inner product helper with %repRing . %repRing %l %br transposed %l"><block var="plus"/><block var="times"/><block s="reportListItem"><l>1</l><block var="a"/></block><block var="tb"/></custom-block><custom-block s="inner product helper with %repRing . %repRing %l %br transposed %l"><block var="plus"/><block var="times"/><block s="reportCDR"><block var="a"/></block><block var="tb"/></custom-block></block></block></script></block-definition><block-definition s="transpose $⍉-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="168" collapsed="false">Takes a multidimensional array, and&#xD;reports an array whose dimensions&#xD;are reversed (as reported by&#xD;SHAPE OF).  In the case of a&#xD;two-dimensional array, does the usual transposition of rows and columns.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>lists</l></list><l>return lists.strideTranspose();</l></block><list><block var="array"/></list></block></block></script><scripts><script x="690.0310872395834" y="485.55555555555566"><block var="array"/></script></scripts></block-definition><block-definition s="reverse row order (column contents) $⦵-1.5-255-255-0 %&apos;list&apos;" type="reporter" category="lists"><comment x="0" y="0" w="286" collapsed="false">Reverses the order of the (toplevel) items of the input.&#xD;&#xD;If the input is a matrix, this means it reverses the order of the rows, which is a reflection through a horizontal axis, as the ⦵ symbol suggests.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportListAttribute"><l><option>reverse</option></l><block var="list"/></block></block></script></block-definition><block-definition s="multimap %&apos;function&apos; %&apos;data&apos;" type="reporter" category="other"><comment x="0" y="0" w="215.33333333333334" collapsed="false">Like MAP, but can take any number of lists&#xD;as inputs.  The lists must all be the same size.&#xD;The function input must take a number of inputs&#xD;equal to the number of lists.  MULTIMAP calls&#xD;the function with all the first items, then all the&#xD;second items, and so on.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%mult%l"></input></inputs><script><block s="doWarp"><script><block s="doDeclareVariables"><list><l>lengths</l><l>cols</l></list></block><block s="doSetVar"><l>lengths</l><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListAttribute"><l><option>length</option></l><l/></block></autolambda><list></list></block><block var="data"/></block></block><block s="doFor"><l>i</l><l>2</l><block s="reportListAttribute"><l><option>length</option></l><block var="lengths"/></block><script><block s="doIf"><block s="reportNot"><block s="reportEquals"><block s="reportListItem"><l>1</l><block var="lengths"/></block><block s="reportListItem"><block var="i"/><block var="lengths"/></block></block></block><script><custom-block s="error %txt"><l>Non-conforming shapes.</l></custom-block></script></block></script></block><block s="doSetVar"><l>cols</l><block s="reportListAttribute"><l><option>columns</option></l><block var="data"/></block></block><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="function"/><custom-block s="%s"><l></l></custom-block></block></autolambda><list></list></block><block var="cols"/></block></block></script></block></script></block-definition><block-definition s="generalized dotproduct %&apos;a&apos; %&apos;b&apos; with sum %&apos;sum&apos; product %&apos;product&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input><input type="%repRing"></input><input type="%repRing"></input></inputs><script><block s="doReport"><block s="reportCombine"><custom-block s="multimap %repRing %mult%l"><block var="product"/><list><block var="a"/><block var="b"/></list></custom-block><block var="sum"/></block></block></script></block-definition><block-definition s="inner product %&apos;a&apos; %&apos;plus&apos; $.-1-255-255-0 %&apos;times&apos; %&apos;b&apos;" type="reporter" category="lists"><comment x="0" y="0" w="252.66666666666666" collapsed="false">Computes a generalized matrix multiplication.&#xD;&#xD;In normal matrix multiplication, each cell of the result&#xD;is computed by multiplying individual numbers within&#xD;a row of the left input and a column of the right input,&#xD;and then adding those products.  In APL terms this is&#xD;+.× (&quot;plus dot times&quot;)&#xD;Any dyadic functions can replace addition and multiplication in this algorithm; a common case is&#xD;∨.∧ (&quot;or dot and&quot;)</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%repRing"></input><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="a"/><l><option>list</option></l></block></block><script><block s="doSetVar"><l>a</l><block s="reportNewList"><list><block var="a"/></list></block></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="b"/><l><option>list</option></l></block></block><script><block s="doSetVar"><l>b</l><block s="reportNewList"><list><block var="b"/></list></block></block></script></block><block s="doIf"><block s="reportAnd"><block s="reportEquals"><block s="reportListItem"><l><option>last</option></l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="a"/></custom-block></block><l>1</l></block><block s="reportGreaterThan"><block s="reportListItem"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="b"/></custom-block></block><l>1</l></block></block><script><block s="doDeclareVariables"><list><l>ta</l></list></block><block s="doSetVar"><l>ta</l><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="a"/></custom-block></block><block s="doSetVar"><l>a</l><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><block var="ta"/></autolambda><list></list></block><block s="reportNumbers"><l>1</l><block s="reportListItem"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="b"/></custom-block></block></block></block></custom-block></block></script></block><block s="doIf"><block s="reportAnd"><block s="reportGreaterThan"><block s="reportListItem"><l><option>last</option></l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="a"/></custom-block></block><l>1</l></block><block s="reportEquals"><block s="reportListItem"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="b"/></custom-block></block><l>1</l></block></block><script><block s="doSetVar"><l>b</l><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><block var="b"/></autolambda><list></list></block><block s="reportNumbers"><l>1</l><block s="reportListItem"><l><option>last</option></l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="a"/></custom-block></block></block></block></block></script></block><block s="doReport"><custom-block s="inner product helper with %repRing . %repRing %l %br transposed %l"><block var="plus"/><block var="times"/><block var="a"/><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="b"/></custom-block></custom-block></block></script></block-definition><block-definition s="min %&apos;a&apos; $⌊-1.2-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="211.33333333333334" collapsed="true">Reports the smaller of its two inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="reportMin"><block var="a"/><block var="b"/></block></block></script></block-definition><block-definition s="combine in rows (reduce by column vectors) %&apos;func&apos; $/-1-255-255-0 %&apos;stuff&apos;" type="reporter" category="lists"><comment x="0" y="0" w="288.6666666666667" collapsed="false">This function has two names because there are two ways&#xD;to understand it.&#xD;&#xD;Lisp way:  A matrix is a list of rows.  This block combines the numbers in each row, producing one value for the entire row.&#xD;&#xD;APL way:  A matrix is made of vectors.  This block takes each column as a vector, and does vector arithmetic on the columns, producing one column as the result.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="stuff"/></custom-block><l>1</l></block><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block var="func"/><l/></custom-block></autolambda><list></list></block><block var="stuff"/></block></block></script><script><block s="doReport"><block s="reportCombine"><block var="stuff"/><block var="func"/></block></block></script></block></script></block-definition><block-definition s="%&apos;howmany&apos; deal helper %&apos;data&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doIf"><block s="reportEquals"><block var="howmany"/><l>0</l></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doDeclareVariables"><list><l>choices</l><l>index</l></list></block><block s="doSetVar"><l>choices</l><block s="reportNewList"><list></list></block></block><block s="doRepeat"><block var="howmany"/><script><block s="doSetVar"><l>index</l><block s="reportRandom"><l>1</l><block s="reportListAttribute"><l><option>length</option></l><block var="data"/></block></block></block><block s="doAddToList"><block s="reportListItem"><block var="index"/><block var="data"/></block><block var="choices"/></block><block s="doDeleteFromList"><block var="index"/><block var="data"/></block></script></block><block s="doReport"><block var="choices"/></block></script></block></script></block-definition><block-definition s="signum $×-1-255-255-0 %&apos;num&apos;" type="reporter" category="operators"><comment x="0" y="0" w="159.99999999999997" collapsed="false">Reports 1 if the input is positive,&#xD;0 if the input is zero,&#xD;or -1 if the input is negative.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="num"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><custom-block s="signum $×-1-255-255-0 %n"><l></l></custom-block></autolambda><list></list></block><block var="num"/></block></block></script></block><block s="doIf"><block s="reportListContainsItem"><block s="reportNewList"><list><l>0</l><block s="reportBoolean"><l><bool>false</bool></l></block></list></block><block var="num"/></block><script><block s="doReport"><l>0</l></block></script></block><block s="doReport"><block s="reportQuotient"><block var="num"/><block s="reportMonadic"><l><option>abs</option></l><block var="num"/></block></block></block></script></block-definition><block-definition s="reciprocal $÷-1-255-255-0 %&apos;num&apos;" type="reporter" category="operators"><comment x="0" y="0" w="102.66666666666667" collapsed="false">reports 1 divided&#xD;by its input.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doReport"><block s="reportQuotient"><l>1</l><block var="num"/></block></block></script></block-definition><block-definition s="roll $?-1-255-255-0 %&apos;num&apos;" type="reporter" category="operators"><comment x="0" y="0" w="180.66666666666666" collapsed="false">This block reports a random integer between 1 and its input.  To roll more than one die, use (for three dice)&#xD;roll (reshape as 3 items of 6)&#xD;APL:  ?3⍴6&#xD;Don&apos;t use reshape as 3 items of (roll 6), because that would roll one die and report 3 copies of the same random roll. </comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doReport"><block s="reportRandom"><l>1</l><block var="num"/></block></block></script></block-definition><block-definition s="scalar? %&apos;x&apos;" type="predicate" category="other"><comment x="0" y="0" w="199.33333333333334" collapsed="false">Reports True if the input is an APL scalar,&#xD;i.e., either an atomic (non-list) value, or&#xD;an array (list of lists) of any depth with only&#xD;one atomic item, e.g., (list (list (list (3)))).</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="x"/><l><option>list</option></l></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doReport"><block s="reportEquals"><block s="reportAtomicCombine"><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="x"/></custom-block><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block></block><l>1</l></block></block></script></block-definition><block-definition s="scalar-value helper %&apos;x&apos;" type="reporter" category="other"><comment x="0" y="0" w="200.66666666666666" collapsed="false">The input must be a value for which SCALAR? reports true, i.e., either an atom or a list of any depth but only one scalar item of item of... etc.  This function returns the underlying scalar (number, etc.).</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="x"/><l><option>list</option></l></block></block><script><block s="doReport"><block var="x"/></block></script></block><block s="doReport"><custom-block s="scalar-value helper %s"><block s="reportListItem"><l>1</l><block var="x"/></block></custom-block></block></script></block-definition><block-definition s="NAND %&apos;a&apos; $⍲-1.4-255-255-0 %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="198.66666666666666" collapsed="false">Reports the not-and of its inputs, in the form&#xD;0 for false, 1 for true.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="NOT $&#126;-1-255-255-0 %s"><custom-block s="LCM (and) %n $∧-1.2-255-255-0 %n"><block var="a"/><block var="b"/></custom-block></custom-block></block></script></block-definition><block-definition s="NOR %&apos;a&apos; $⍱-1.4-255-255-0 %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="198.66666666666666" collapsed="false">Reports the not-and of its inputs, in the form&#xD;0 for false, 1 for true.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="NOT $&#126;-1-255-255-0 %s"><custom-block s="GCD (or) %n $∨-1.2-255-255-0 %n"><block var="a"/><block var="b"/></custom-block></custom-block></block></script></block-definition><block-definition s="%&apos;a&apos; ≤ %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="151.33333333333334" collapsed="true">Reports True if the left input is&#xD;less than or equal to the right input.&#xD;&#xD;Reports a Snap! Boolean, not an integer 0 or 1.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="reportLessThanOrEquals"><block var="a"/><block var="b"/></block><comment w="176.66666666666666" collapsed="true">This is the primitive version.</comment></block></script></block-definition><block-definition s="%&apos;a&apos; ≥ %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="152.66666666666666" collapsed="false">Reports True if the left input is&#xD;greater than than or equal to&#xD;the right input.&#xD;&#xD;Reports a Snap! Boolean, not an integer 0 or 1.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="reportGreaterThanOrEquals"><block var="a"/><block var="b"/></block></block></script></block-definition><block-definition s="XOR %&apos;a&apos; $≠-1-255-255-0 %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="190" collapsed="false">Reports False if its inputs are equal;&#xD;reports True if its inputs are not equal.&#xD;The inputs can have any non-list values.&#xD;(Lists are hyperized.)  If the inputs are&#xD;Booleans (True/False or 1/0), this is&#xD;also the exclusive-or function.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="%s scalar %s %s"><block var="a"/><l>≠</l><block var="b"/></custom-block></block></script></block-definition><block-definition s="zero? %&apos;n&apos;" type="predicate" category="other"><comment x="0" y="0" w="202.66666666666666" collapsed="true">reports True iff the input is 0 or False.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doReport"><block s="reportListContainsItem"><block s="reportNewList"><list><l>0</l><block s="reportBoolean"><l><bool>false</bool></l></block></list></block><block var="n"/></block></block></script></block-definition><block-definition s="truth %&apos;n&apos;" type="predicate" category="other"><comment x="0" y="0" w="198.66666666666666" collapsed="false">Reports a Snap! Boolean False if the input&#xD;is False or 0; reports True otherwise.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="n"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="truth %s"><l></l></custom-block></autolambda><list></list></block><block var="n"/></block></block></script></block><block s="doReport"><block s="reportIfElse"><block s="reportIsA"><block var="n"/><l><option>Boolean</option></l></block><block var="n"/><block s="reportNot"><block s="reportEquals"><block var="n"/><l>0</l></block></block></block></block></script></block-definition><block-definition s="make scalar %&apos;value&apos;" type="reporter" category="operators"><comment x="0" y="0" w="242.66666666666666" collapsed="false">Turns list of list of ... a single scalar (e.g., ((((x)))) ) into just the scalar.  Error if called with anything else.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><custom-block s="scalar? %s"><block var="value"/></custom-block><script><block s="doReport"><custom-block s="scalar-value helper %s"><block var="value"/></custom-block></block></script></block><custom-block s="error %txt"><block s="reportJoinWords"><list><l>Make scalar called with non-singleton input </l><block var="value"/></list></block></custom-block></script></block-definition><block-definition s="$⍳-1.5-255-255-0 %&apos;n&apos;" type="reporter" category="lists"><comment x="0" y="0" w="290.6666666666667" collapsed="false">If the input is a positive integer, reports a list of the numbers&#xD;from 1 to that input.  (If the input is 0, reports an empty list.)&#xD;&#xD;If the input is a list of positive integers, reports an array with&#xD;the shape specified by the input (as in ⍴ reshape) in which&#xD;each item is a list of the indices of that item in the array&#xD;(so technically the shape has one more dimension&#xD;than the input, whose size is the size of the input).&#xD;&#xD;For list inputs, the size of the result grows very quickly, more or less the factorial of the size of the input.  Snap! will not attempt to compute a result bigger than a few million atomic items.&#xD;⍳(⍳ 9) will work (≈ 3 million atoms) but ⍳(⍳ 10) will give an error.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="n"/><l><option>list</option></l></block><script><block s="doIfElse"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="n"/></custom-block><l>1</l></block><script><block s="doIfElse"><block s="reportListContainsItem"><block var="n"/><l>0</l></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doReport"><block s="reportReshape"><custom-block s="crossproduct %mult%l"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><block s="reportNumbers"><l>1</l><l></l></block></autolambda><list></list></block><block var="n"/></block></custom-block><block s="reportConcatenatedLists"><list><block var="n"/><block s="reportNewList"><list><block s="reportListAttribute"><l><option>length</option></l><block var="n"/></block></list></block></list></block></block></block></script></block></script><script><custom-block s="error %txt"><l>Input to ⍳ can&apos;t be a list of lists.</l></custom-block></script></block></script><script><block s="doReport"><block s="reportIfElse"><custom-block s="zero? %n"><block var="n"/></custom-block><block s="reportNewList"><list></list></block><block s="reportNumbers"><l>1</l><block var="n"/></block></block></block></script></block></script></block-definition><block-definition s="where in %&apos;vector&apos; is $⍳-1.5-255-255-0 %&apos;items&apos;" type="reporter" category="lists"><comment x="0" y="0" w="334.6666666666667" collapsed="false">If the rank of the left input is one more than the rank of the right input,&#xD;reports the index of the right input in the left input, or if not found,&#xD;reports one more than the length of the left input.&#xD;&#xD;If the rank of the left input is equal to the rank of the right input,&#xD;reports a vector of the indices of the items of the right input&#xD;in the left input (mapping this function over the right input).&#xD;&#xD;If the rank of the left input is more than that of the right input by 2 or more,&#xD;reports a vector, the location of the right input in the left in each dimension.&#xD;&#xD;It is an error if the rank of the left input is less than that of the right input.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%s"></input></inputs><script><block s="doDeclareVariables"><list><l>result</l></list></block><block s="doIf"><block s="reportLessThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vector"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="items"/></custom-block></block><script><custom-block s="error %txt"><l>Left input to ⍳ must have greater or equal rank to right input.</l></custom-block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vector"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="items"/></custom-block></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="where in %l is $⍳-1.5-255-255-0 %s"><block var="vector"/><l></l></custom-block></autolambda><list></list></block><block var="items"/></block></block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vector"/></custom-block><block s="reportSum"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="items"/></custom-block><l>1</l></block></block><script><block s="doSetVar"><l>result</l><block s="reportListIndex"><block var="items"/><block var="vector"/></block></block><block s="doReport"><block s="reportIfElse"><custom-block s="zero? %n"><block var="result"/></custom-block><block s="reportSum"><block s="reportListAttribute"><l><option>length</option></l><block var="vector"/></block><l>1</l></block><block var="result"/></block></block></script></block><block s="doSetVar"><l>result</l><block s="reportFindFirst"><block s="reifyPredicate"><autolambda><custom-block s="%l deep contains %s"><l/><block var="items"/></custom-block></autolambda><list></list></block><block var="vector"/></block></block><block s="doIf"><block s="reportEquals"><block var="result"/><l></l></block><script><block s="doReport"><block s="reportSum"><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="vector"/></custom-block><l>1</l></block></block></script></block><block s="doReport"><block s="reportCONS"><block s="reportListIndex"><block var="result"/><block var="vector"/></block><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><custom-block s="where in %l is $⍳-1.5-255-255-0 %s"><block var="result"/><block var="items"/></custom-block></custom-block></block></block></script></block-definition><block-definition s="crossproduct %&apos;lists&apos;" type="reporter" category="lists"><comment x="0" y="0" w="305.3333333333333" collapsed="false">This isn&apos;t an APL function, although it&apos;s related to the outer product.&#xD;&#xD;It takes any number of lists, and reports a list of all possible tuples with one item from each of the lists.  The length of the result is the product of the lengths of the inputs.&#xD;&#xD;The result gets very big very quickly.  Snap! will refuse to do this computation if the result would be more than a few million atomic items.  (crossproduct (⍳(⍳9))) makes about 3 million atomic items; (crossproduct (⍳(⍳10))) gives an error message.</comment><header></header><code></code><translations></translations><inputs><input type="%mult%l"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>lists</l></list><l>return lists.crossproduct();</l></block><list><block var="lists"/></list></block></block></script></block-definition><block-definition s="%&apos;array&apos; deep contains %&apos;value&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="array"/><l><option>list</option></l></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>false</bool></l></block></block></script></block><block s="doIf"><block s="reportListContainsItem"><block var="array"/><block var="value"/></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doReport"><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block s="reifyReporter"><autolambda><block s="reportOr"><l/><l/></block></autolambda><list></list></block><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="%l deep contains %s"><l/><block var="value"/></custom-block></autolambda><list></list></block><block var="array"/></block></custom-block></block></script></block-definition><block-definition s="which of %&apos;items&apos; $ϵ-1-255-255-0 contained in %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="214.66666666666666" collapsed="false">Reports an array of Booleans the same shape&#xD;as the left input, indicating which of the atoms&#xD;in the left input appear anywhere in the right&#xD;input.  &#xD;(The structure of the right input doesn&apos;t matter.)</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="items"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><custom-block s="which of %s $ϵ-1-255-255-0 contained in %l"><l></l><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><block var="array"/></custom-block></custom-block></autolambda><list></list></block><block var="items"/></block></block></script><script><block s="doReport"><block s="reportListContainsItem"><custom-block s="flatten (ravel) $,-1-255-255-0 %l"><block var="array"/></custom-block><block var="items"/></block></block></script></block></script></block-definition><block-definition s="catenate %&apos;left&apos; $,-1-255-255-0 %&apos;right&apos;" type="reporter" category="lists"><comment x="0" y="0" w="190.66666666666666" collapsed="false">Like append, but:&#xD;&#xD;A scalar input is treated as an array the same shape as the other input except that the last item of the shape is 1.&#xD;&#xD;If the two inputs are of different ranks,&#xD;the function is mapped over the larger ranked input.&#xD;&#xD;Catenate adds new columns, by appending to each row.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="left"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>left</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>-1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="right"/></custom-block></custom-block><block s="reportNewList"><list><l>1</l></list></block></list></block><block s="reportNewList"><list><block var="left"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>left</l><block s="reportNewList"><list><block var="left"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="right"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>right</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>-1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="left"/></custom-block></custom-block><block s="reportNewList"><list><l>1</l></list></block></list></block><block s="reportNewList"><list><block var="right"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>right</l><block s="reportNewList"><list><block var="right"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doIfElse"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doReport"><block s="reportConcatenatedLists"><list><block var="left"/><block var="right"/></list></block></block></script><script><block s="doReport"><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block><list><block var="left"/><block var="right"/></list></custom-block></block></script></block></script></block><block s="doIfElse"><block s="reportLessThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><block var="left"/><l></l></custom-block></autolambda><list></list></block><block var="right"/></block></block></script><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><block var="right"/></custom-block></autolambda><list></list></block><block var="left"/></block></block></script></block></script></block-definition><block-definition s="scalar value %&apos;value&apos;" type="reporter" category="lists"><comment x="0" y="0" w="221.33333333333334" collapsed="false">If the input is a nesting of length=1 lists, which&#xD;APL treats as a scalar (the innermost item)&#xD;for many purposes, report that innermost scalar.&#xD;Otherwise, report the input as is.&#xD;&#xD;Exposing this block for users is important because Snap! /does not/ treat such a nesting&#xD;as a scalar, so you might need to use this in&#xD;translating an APL program to Snap!.&#xD;(But the functions in the APL library already use&#xD;this block as needed.)</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="reportIfElse"><custom-block s="scalar? %s"><block var="value"/></custom-block><custom-block s="scalar-value helper %s"><block var="value"/></custom-block><block var="value"/></block></block></script></block-definition><block-definition s="grade up $⍋-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="190.66666666666666" collapsed="false">Reports a vector of indices of the items of the input, in order of the values of the items, so that&#xD;&#xD;item (grade up (foo)) of (foo)&#xD;&#xD;reports the items in sorted order, smallest to largest.  For a matrix, sorts the rows based on their first items, or if those are equal, based on their second items, etc.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l><option>last</option></l><l/></block></autolambda><list></list></block><custom-block s="$flash sort %l ordering with %predRing"><custom-block s="multimap %repRing over %mult%l"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block><list><block var="array"/><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportListAttribute"><l><option>length</option></l><block var="array"/></block></custom-block></list></custom-block><block s="reifyPredicate"><autolambda><custom-block s="sort helper %l %l"><l/><l/></custom-block></autolambda><list></list></block></custom-block></block></block></script></block-definition><block-definition s="sort helper %&apos;rowA&apos; %&apos;rowB&apos;" type="reporter" category="other"><comment x="0" y="0" w="166" collapsed="false">Compares two vectors for sorting.&#xD;Compare first items; if those are equal compare second items; etc.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="rowA"/></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doIf"><block s="reportListIsEmpty"><block var="rowB"/></block><script><block s="doReport"><block s="reportBoolean"><l><bool>false</bool></l></block></block></script></block><block s="doIf"><block s="reportLessThan"><block s="reportListItem"><l>1</l><block var="rowA"/></block><block s="reportListItem"><l>1</l><block var="rowB"/></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doIf"><block s="reportGreaterThan"><block s="reportListItem"><l>1</l><block var="rowA"/></block><block s="reportListItem"><l>1</l><block var="rowB"/></block></block><script><block s="doReport"><block s="reportBoolean"><l><bool>false</bool></l></block></block></script></block><block s="doReport"><custom-block s="sort helper %l %l"><block s="reportCDR"><block var="rowA"/></block><block s="reportCDR"><block var="rowB"/></block></custom-block></block></script></block-definition><block-definition s="grade down $⍒-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="190.66666666666666" collapsed="false">Reports a vector of indices of the items of the input, in order of the values of the items, so that&#xD;&#xD;item (grade down (foo)) of (foo)&#xD;&#xD;reports the items in sorted order, largest to smallest.  For a matrix, sorts the rows based on their first items, or if those are equal, based on their second items, etc.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l><option>last</option></l><l/></block></autolambda><list></list></block><custom-block s="$flash sort %l ordering with %predRing"><custom-block s="multimap %repRing over %mult%l"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><l></l></custom-block></autolambda><list></list></block><list><block var="array"/><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportListAttribute"><l><option>length</option></l><block var="array"/></block></custom-block></list></custom-block><block s="reifyPredicate"><autolambda><custom-block s="NOT $&#126;-1-255-255-0 %s"><custom-block s="sort helper %l %l"><l/><l/></custom-block></custom-block></autolambda><list></list></block></custom-block></block></block></script></block-definition><block-definition s="select rows (compress columns) %&apos;Booleans&apos; $/-1-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="210.66666666666666" collapsed="false">The left input must be a vector of Booleans&#xD;(either Snap! form or APL form); the right input must be an array whose first dimension is equal to the length of the left input.  The block reports an array of the same rank as the right input, containing only those items (rows, for a matrix) for which the corresponding Boolean is True (or 1).</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="rowize vector %l"><block s="reportAtomicKeep"><block s="reifyPredicate"><autolambda><custom-block s="truth %s"><block s="reportListItem"><block var="index"/><block var="Booleans"/></block></custom-block></autolambda><list><l>value</l><l>index</l></list></block><block var="array"/></block></custom-block></block></script></block-definition><block-definition s="rowize vector %&apos;vec&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportIfElse"><block s="reportAnd"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="vec"/></custom-block><l>2</l></block><block s="reportEquals"><block s="reportListItem"><l>2</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="vec"/></custom-block></block><l>1</l></block></block><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportListItem"><l>1</l><l/></block></autolambda><list></list></block><block var="vec"/></block><block var="vec"/></block></block></script></block-definition><block-definition s="select columns (compress rows) %&apos;bool&apos; $⌿-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="219.33333333333334" collapsed="false">The left input must be a vector of Booleans&#xD;(either Snap! form or APL form); the right input must be an array whose last dimension is equal to the length of the left input.  The block reports an array of the same rank as the right input, containing only those items (columns, for a matrix) for which the corresponding Boolean is True (or 1).</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="columnwise %repRing %l"><block s="reifyReporter"><autolambda><custom-block s="select rows (compress columns) %l $/-1-255-255-0 %l"><block var="bool"/><l/></custom-block></autolambda><list></list></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="columnwise %&apos;function&apos; %&apos;data&apos;" type="reporter" category="control"><comment x="0" y="0" w="212" collapsed="false">Turns a row-wise (in Lisp terminology) function&#xD;into a column-wise one.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="rowize vector %l"><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block s="evaluate"><block var="function"/><list><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="data"/></custom-block></list></block></custom-block></custom-block></block></script></block-definition><block-definition s="reverse column order (row contents) $⏀-1-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="206" collapsed="false">Reverses the order of the columns of the input, which is a reflection through a vertical axis, as the ⏀ symbol suggests.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="columnwise %repRing %l"><block s="reifyReporter"><autolambda><custom-block s="reverse row order (column contents) $⦵-1.5-255-255-0 %l"><l/></custom-block></autolambda><list></list></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="combine in columns (reduce by row vectors) %&apos;function&apos; $⌿-1.5-255-255-0 %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="285.3333333333333" collapsed="false">This function has two names because there are two ways&#xD;to understand it.&#xD;&#xD;Lisp way:  A matrix is a list of rows.  This block turns it into a list of columns, and combines the numbers in each column, producing one value for the entire column.&#xD;&#xD;APL way:  A matrix is made of vectors.  This block takes each row as a vector, and does vector arithmetic on the rows, producing one row as the result.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="columnwise %repRing %l"><block s="reifyReporter"><autolambda><custom-block s="combine in rows (reduce by column vectors) %repRing $/-1-255-255-0 %l"><block var="function"/><l/></custom-block></autolambda><list></list></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="catenate vertically %&apos;left&apos; $⍪-1.5-255-255-0 %&apos;right&apos;" type="reporter" category="lists"><comment x="0" y="0" w="190.66666666666666" collapsed="false">Like append, but:&#xD;&#xD;A scalar input is treated as a vector&#xD;of length 1.&#xD;&#xD;If the two inputs are of different ranks,&#xD;the function is mapped over the larger ranked input.&#xD;&#xD;Catenate vertically adds new rows, by appending to each column.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="left"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>left</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><block s="reportNewList"><list><l>1</l></list></block><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="right"/></custom-block></custom-block></list></block><block s="reportNewList"><list><block var="left"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>left</l><block s="reportNewList"><list><block var="left"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="right"/><l><option>list</option></l></block></block><script><block s="doIfElse"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doSetVar"><l>right</l><custom-block s="reshape as %l $⍴-1-255-255-0 items of %l"><block s="reportConcatenatedLists"><list><block s="reportNewList"><list><l>1</l></list></block><custom-block s="drop %n $↓-1-255-255-0 from %l"><l>1</l><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="left"/></custom-block></custom-block></list></block><block s="reportNewList"><list><block var="right"/></list></block></custom-block></block></script><script><block s="doSetVar"><l>right</l><block s="reportNewList"><list><block var="right"/></list></block></block></script></block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doIfElse"><block s="reportEquals"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><l>1</l></block><script><block s="doReport"><block s="reportConcatenatedLists"><list><block var="left"/><block var="right"/></list></block></block></script><script><block s="doReport"><custom-block s="transpose $⍉-1.5-255-255-0 %l"><custom-block s="catenate %s $,-1-255-255-0 %s"><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="left"/></custom-block><custom-block s="transpose $⍉-1.5-255-255-0 %l"><block var="right"/></custom-block></custom-block></custom-block></block></script></block></script></block><block s="doIfElse"><block s="reportLessThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="left"/></custom-block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="right"/></custom-block></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><block var="left"/><l></l></custom-block></autolambda><list></list></block><block var="right"/></block></block></script><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="catenate %s $,-1-255-255-0 %s"><l></l><block var="right"/></custom-block></autolambda><list></list></block><block var="left"/></block></block></script></block></script><scripts><script x="254" y="497.7777777777774"><custom-block s="multimap %repRing %mult%l"><block s="reifyReporter"><script></script><list></list></block><list><l/><l/></list></custom-block></script></scripts></block-definition><block-definition s="%&apos;a&apos; scalar join %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="219.33333333333334" collapsed="false">A hyperblock version of JOIN.  The regular JOIN isn&apos;t hyperized because it can accept a list as input, representing it as text.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><block s="reportJoinWords"><list><l></l><l></l></list></block></autolambda><list></list></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="take %&apos;howmany&apos; $↑-1-255-255-0 from %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="272" collapsed="false">A positive left input selects the first n items of the right input.&#xD;A negative left input selects the last abs(n) items&#xD;of the right input.&#xD;&#xD;If the right input is a matrix, a numeric left input selects rows;&#xD;the left input may also be a two-item vector, in which case&#xD;the first number is applied to the rows&#xD;and the second number is applied to the columns.&#xD;Similarly for higher-dimension arrays. </comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="howmany"/><l><option>number</option></l></block><script><block s="doReport"><block s="reportIfElse"><block s="reportLessThan"><block var="howmany"/><l>0</l></block><block s="reportListItem"><block s="reportSum"><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportMonadic"><l><option>abs</option></l><block var="howmany"/></block></custom-block><block s="reportSum"><block s="reportListAttribute"><l><option>length</option></l><block var="array"/></block><block var="howmany"/></block></block><block var="array"/></block><block s="reportListItem"><custom-block s="$⍳-1.5-255-255-0 %n"><block var="howmany"/></custom-block><block var="array"/></block></block></block></script></block><block s="doIf"><block s="reportGreaterThan"><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="howmany"/></custom-block><l>1</l></block><script><custom-block s="error %txt"><l>Left input to take can&apos;t be a matrix.</l></custom-block></script></block><block s="doIf"><block s="reportGreaterThan"><block s="reportListAttribute"><l><option>length</option></l><block var="howmany"/></block><custom-block s="rank of $⍴⍴-1-255-255-0 %l"><block var="array"/></custom-block></block><script><custom-block s="error %txt"><l>Length of item vector &gt; rank of array in take.</l></custom-block></script></block><block s="doReport"><block s="reportListItem"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportIfElse"><block s="reportLessThan"><block var="value"/><l>0</l></block><block s="reportSum"><custom-block s="$⍳-1.5-255-255-0 %n"><block s="reportMonadic"><l><option>abs</option></l><block var="value"/></block></custom-block><block s="reportSum"><block s="reportListItem"><block var="index"/><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></block><block var="value"/></block></block><custom-block s="$⍳-1.5-255-255-0 %n"><block var="value"/></custom-block></block></autolambda><list><l>value</l><l>index</l></list></block><block var="howmany"/></block><block var="array"/></block></block></script></block-definition><block-definition s="drop %&apos;howmany&apos; $↓-1-255-255-0 from %&apos;array&apos;" type="reporter" category="lists"><comment x="0" y="0" w="306" collapsed="false">A positive left input selects all but the first n items of the right input.&#xD;A negative left input selects all but the last abs(n) items&#xD;of the right input.&#xD;&#xD;If the right input is a matrix, a numeric left input selects rows;&#xD;the left input may also be a two-item vector, in which case&#xD;the first number is applied to the rows&#xD;and the second number is applied to the columns.&#xD;Similarly for higher-dimension arrays. </comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="howmany"/><l><option>number</option></l></block><script><block s="doReport"><custom-block s="take %n $↑-1-255-255-0 from %l"><block s="reportProduct"><block s="reportMonadic"><l><option>neg</option></l><custom-block s="signum $×-1-255-255-0 %n"><block var="howmany"/></custom-block></block><block s="reportDifference"><block s="reportListAttribute"><l><option>length</option></l><block var="array"/></block><block s="reportMonadic"><l><option>abs</option></l><block var="howmany"/></block></block></block><block var="array"/></custom-block></block></script></block><block s="doReport"><custom-block s="take %n $↑-1-255-255-0 from %l"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="reportIfElse"><block s="reportLessThan"><block var="value"/><l>0</l></block><block s="reportSum"><block s="reportListItem"><block var="index"/><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></block><block var="value"/></block><block s="reportDifference"><block var="value"/><block s="reportListItem"><block var="index"/><custom-block s="shape of $⍴-1-255-255-0 %l"><block var="array"/></custom-block></block></block></block></autolambda><list><l>value</l><l>index</l></list></block><block var="howmany"/></block><block var="array"/></custom-block></block></script></block-definition><block-definition s="time %&apos;thunk&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%repRing"></input></inputs><script><block s="doDeclareVariables"><list><l>start time</l></list></block><block s="doSetVar"><l>start time</l><block s="reportDate"><l><option>time in milliseconds</option></l></block></block><custom-block s="ignore %s"><block s="evaluate"><block var="thunk"/><list></list></block></custom-block><block s="doReport"><block s="reportDifference"><block s="reportDate"><l><option>time in milliseconds</option></l></block><block var="start time"/></block></block></script></block-definition><block-definition s="ignore %&apos;value&apos;" type="command" category="other"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs></block-definition><block-definition s="error %&apos;msg&apos;" type="command" category="control"><comment x="0" y="0" w="268.6666666666667" collapsed="false">Throw an error.&#xD;&#xD;Makes a red halo appear around the script that runs it,&#xD;with the input text shown in a speech balloon next to&#xD;the script, just like any Snap! error.&#xD;&#xD;This is useful to put in the second script of SAFELY TRY&#xD;after some other instructions to undo the partial work of&#xD;the first script.</comment><header></header><code></code><translations>pt:lança o erro _&#xD;</translations><inputs><input type="%txt"></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>msg</l></list><l>throw new Error(msg);</l></block><list><block var="msg"/></list></block></script></block-definition><block-definition s="simple log base %&apos;b&apos; of %&apos;n&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="reportQuotient"><block s="reportMonadic"><l><option>ln</option></l><block var="n"/></block><block s="reportMonadic"><l><option>ln</option></l><block var="b"/></block></block></block></script></block-definition><block-definition s="simple permutations of %&apos;r&apos; items out of %&apos;n&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="reportIfElse"><block s="reportEquals"><block var="r"/><l>0</l></block><l>1</l><block s="reportAtomicCombine"><block s="reportNumbers"><block s="reportSum"><block s="reportDifference"><block var="n"/><block var="r"/></block><l>1</l></block><block var="n"/></block><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block></block></block></block></script></block-definition><block-definition s="simple combs %&apos;r&apos; out of %&apos;n&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="reportQuotient"><custom-block s="simple permutations of %n items out of %n"><block var="r"/><block var="n"/></custom-block><custom-block s="factorial $!-1-255-255-0 %n"><block var="r"/></custom-block></block></block></script></block-definition><block-definition s="numbers from %&apos;from&apos; to %&apos;to&apos; ascending" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><custom-block s="simple numbers from %n to %n ascending"><l></l><l></l></custom-block></autolambda><list></list></block></custom-block><list><block var="from"/><block var="to"/></list></block></block></script></block-definition><block-definition s="simple gcd %&apos;a&apos; %&apos;b&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doIf"><block s="reportEquals"><block var="b"/><l>0</l></block><script><block s="doReport"><block var="a"/></block></script></block><block s="doReport"><custom-block s="simple gcd %n %n"><block var="b"/><block s="reportModulus"><block var="a"/><block var="b"/></block></custom-block></block></script></block-definition><block-definition s="de-boolean %&apos;n&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="n"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="de-boolean %s"><l></l></custom-block></autolambda><list></list></block><block var="n"/></block></block></script><script><block s="doReport"><block s="reportIfElse"><custom-block s="zero? %n"><block var="n"/></custom-block><l>0</l><block s="reportIfElse"><block s="reportEquals"><block var="n"/><block s="reportBoolean"><l><bool>true</bool></l></block></block><l>1</l><block var="n"/></block></block></block></script></block></script></block-definition><block-definition s="simple lcm %&apos;a&apos; %&apos;b&apos;" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doIf"><block s="reportEquals"><block var="b"/><l>0</l></block><script><block s="doReport"><block var="b"/></block></script></block><block s="doReport"><block s="reportProduct"><block var="a"/><block s="reportQuotient"><block var="b"/><custom-block s="simple gcd %n %n"><block var="a"/><block var="b"/></custom-block></block></block></block></script></block-definition><block-definition s="simple numbers from %&apos;from&apos; to %&apos;to&apos; ascending" type="reporter" category="other"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="reportIfElse"><block s="reportGreaterThan"><block var="from"/><block var="to"/></block><block s="reportNewList"><list></list></block><block s="reportNumbers"><block var="from"/><block var="to"/></block></block></block></script></block-definition><block-definition s="$flash sort %&apos;data&apos; ordering with %&apos;function&apos;" type="reporter" category="lists"><comment x="0" y="0" w="161.14285714285708" collapsed="false">Reports a sorted version of the list in its first input slot, using the comparison function in the second input slot.  For a list of numbers, using &lt; as the comparison function will sort from low to high; using &gt; will sort from high to low.</comment><header></header><code></code><translations>ca:ordena _ segons criteri _&#xD;</translations><inputs><input type="%l"></input><input type="%predRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>data</l><l>fn</l><l>proc</l></list><l>return proc.reportAtomicSort(data, fn);</l></block><list><block var="data"/><block var="function"/></list></block></block></script><scripts><script x="12" y="147.55555555555557"><block s="doDeclareVariables"><list><l>even items</l><l>odd items</l><l>merge</l><l>split</l><l>copy of data</l><l>id</l></list></block><block s="doSetVar"><l>id</l><block s="reifyScript"><script><block s="doReport"><l></l></block></script><list></list></block></block><block s="doSetVar"><l>copy of data</l><block s="reportMap"><block var="id"/><block var="data"/></block></block><block s="doSetVar"><l>split</l><block s="reifyScript"><script><block s="doSetVar"><l>even items</l><block s="reportNewList"><list></list></block></block><block s="doSetVar"><l>odd items</l><block s="reportNewList"><list></list></block></block><block s="doUntil"><block s="reportListIsEmpty"><block var="copy of data"/></block><script><block s="doAddToList"><block s="reportListItem"><l>1</l><block var="copy of data"/></block><block var="odd items"/></block><block s="doDeleteFromList"><l>1</l><block var="copy of data"/></block><block s="doIf"><block s="reportNot"><block s="reportListIsEmpty"><block var="copy of data"/></block></block><script><block s="doAddToList"><block s="reportListItem"><l>1</l><block var="copy of data"/></block><block var="even items"/></block><block s="doDeleteFromList"><l>1</l><block var="copy of data"/></block></script></block></script></block></script><list></list></block></block><block s="doSetVar"><l>merge</l><block s="reifyScript"><script><block s="doIf"><block s="reportEquals"><block var="#1"/><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block var="#2"/></block></script></block><block s="doIf"><block s="reportEquals"><block var="#2"/><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block var="#1"/></block></script></block><block s="doIfElse"><block s="evaluate"><block var="function"/><list><block s="reportListItem"><l>1</l><block var="#1"/></block><block s="reportListItem"><l>1</l><block var="#2"/></block></list></block><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="#1"/></block><block s="evaluate"><block var="merge"/><list><block s="reportCDR"><block var="#1"/></block><block var="#2"/></list></block></block></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="#2"/></block><block s="evaluate"><block var="merge"/><list><block var="#1"/><block s="reportCDR"><block var="#2"/></block></list></block></block></block></script></block></script><list><l>#1</l><l>#2</l></list></block></block><block s="doIf"><block s="reportEquals"><block var="data"/><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doIf"><block s="reportEquals"><block s="reportCDR"><block var="data"/></block><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block var="data"/></block></script></block><block s="doRun"><block var="split"/><list></list></block><block s="doReport"><block s="evaluate"><block var="merge"/><list><custom-block s="$flash sort %l ordering with %predRing"><block var="odd items"/><block var="function"/></custom-block><custom-block s="$flash sort %l ordering with %predRing"><block var="even items"/><block var="function"/></custom-block></list></block></block></script></scripts></block-definition><block-definition s="☠︎ linked? %&apos;data&apos;" type="predicate" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>data</l></list><l>return data.isLinked;</l></block><list><block var="data"/></list></block></block></script></block-definition><block-definition s="☠︎ link %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="data"/></block><script><block s="doReport"><block var="data"/></block></script></block><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="data"/></block><block s="reportCDR"><block var="data"/></block></block></block></script></block-definition><block-definition s="printable %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="188.66666666666666" collapsed="false">Takes a (possibly deep) list as input,&#xD;and reports a human-readable text form &#xD;of the list (namely, Lisp notation).&#xD;&#xD;Will not work on circular lists.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><block s="reportNot"><block s="reportIsA"><block var="data"/><l><option>list</option></l></block></block><script><block s="doReport"><block var="data"/></block></script></block><block s="doIf"><block s="reportListIsEmpty"><block var="data"/></block><script><block s="doReport"><l>()</l></block></script></block><block s="doReport"><block s="reportJoinWords"><list><l>(</l><block s="reportAtomicCombine"><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="printable %l"><l/></custom-block></autolambda><list></list></block><block var="data"/></block><block s="reifyReporter"><autolambda><block s="reportJoinWords"><list><l></l><l> </l><l></l></list></block></autolambda><list></list></block></block><l>)</l></list></block></block></script></block-definition><block-definition s="%&apos;x&apos;" type="reporter" category="lists"><comment x="0" y="0" w="105.33333333333333" collapsed="false">The identity function reports its input.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block var="x"/></block></script></block-definition><block-definition s="multimap %&apos;function&apos; over %&apos;lists&apos;" type="reporter" category="lists"><comment x="0" y="0" w="267.3333333333333" collapsed="false">Takes as input a function of N inputs and N lists.&#xD;The function is called with item 1 of all the lists as its inputs, with item 2 of all the lists as its inputs, and so on.  (The lists should all be the same length.)</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%mult%l"></input></inputs><script><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="function"/><custom-block s="%s"><l></l></custom-block></block></autolambda><list></list></block><block s="reportListAttribute"><l><option>columns</option></l><block var="lists"/></block></block></block></script></block-definition><block-definition s="md-replace item %&apos;indices&apos; of %&apos;array&apos; with %&apos;value&apos;" type="command" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input><input type="%s"></input></inputs><script><block s="doIfElse"><block s="reportEquals"><block s="reportListAttribute"><l><option>length</option></l><block var="indices"/></block><l>1</l></block><script><block s="doReplaceInList"><block s="reportListItem"><l>1</l><block var="indices"/></block><block var="array"/><block var="value"/></block></script><script><custom-block s="md-replace item %l of %l with %s"><block s="reportCDR"><block var="indices"/></block><block s="reportListItem"><block s="reportListItem"><l>1</l><block var="indices"/></block><block var="array"/></block><block var="value"/></custom-block></script></block></script></block-definition><block-definition s="md-item %&apos;indices&apos; of %&apos;array&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportEquals"><block s="reportListAttribute"><l><option>length</option></l><block var="indices"/></block><l>1</l></block><script><block s="doReport"><block s="reportListItem"><block s="reportListItem"><l>1</l><block var="indices"/></block><block var="array"/></block></block></script><script><block s="doReport"><custom-block s="md-item %l of %l"><block s="reportCDR"><block var="indices"/></block><block s="reportListItem"><block s="reportListItem"><l>1</l><block var="indices"/></block><block var="array"/></block></custom-block></block></script></block></script></block-definition><block-definition s="md-for each %&apos;item&apos; at position %&apos;indices&apos; of %&apos;array&apos; %&apos;action&apos;" type="command" category="lists"><header></header><code></code><translations></translations><inputs><input type="%upvar"></input><input type="%upvar"></input><input type="%l"></input><input type="%cs"></input></inputs><script><block s="doDeclareVariables"><list><l>shape</l><l>index</l></list></block><block s="doSetVar"><l>shape</l><custom-block s="crossproduct %mult%l"><block s="reportNumbers"><l>1</l><block s="reportListAttribute"><l><option>dimensions</option></l><block var="array"/></block></block></custom-block></block><block s="doSetVar"><l>index</l><l>0</l></block><block s="doForEach"><l>atom</l><block s="reportListAttribute"><l><option>flatten</option></l><block var="array"/></block><script><block s="doChangeVar"><l>index</l><l>1</l></block><block s="doSetVar"><l>item</l><block var="atom"/></block><block s="doSetVar"><l>indices</l><block s="reportListItem"><block var="index"/><block var="shape"/></block></block><block s="doRun"><block var="action"/><list><block var="atom"/></list></block></script></block></script><scripts><script x="22.666666666666668" y="352.88888888888886"><block s="doIfElse"><custom-block s="scalar? %s"><block var="array"/></custom-block><script><block s="doSetVar"><l>item</l><block var="array"/></block><block s="doRun"><block var="action"/><list><block var="array"/></list></block></script><script><block s="doForEach"><l>row</l><block var="array"/><script><custom-block s="md-for each %upvar at position %upvar of %l %cs"><l>subitem</l><l>indices</l><block var="action"/><script></script></custom-block></script></block></script></block></script></scripts></block-definition><block-definition s="scalar -&gt; hyper %&apos;func&apos;" type="reporter" category="control"><comment x="0" y="0" w="218" collapsed="false">Takes a dyadic scalar function as input, and&#xD;hyperizes it, so that it can take lists as inputs.&#xD;&#xD;Don&apos;t use on slow functions (this has compiled map calls).  Meant for use on primitives.</comment><header></header><code></code><translations></translations><inputs><input type="%repRing"></input></inputs><script><block s="doDeclareVariables"><list><l>hyper func</l><l>scalarized</l></list></block><block s="doSetVar"><l>hyper func</l><block s="reifyReporter"><script><block s="doWarp"><script><block s="doIfElse"><custom-block s="scalar? %s"><block var="a"/></custom-block><script><block s="doIfElse"><custom-block s="scalar? %s"><block var="b"/></custom-block><script><block s="doReport"><block s="evaluate"><block var="func"/><list><custom-block s="scalar-value helper %s"><block var="a"/></custom-block><custom-block s="scalar-value helper %s"><block var="b"/></custom-block></list></block></block></script><script><block s="doSetVar"><l>scalarized</l><custom-block s="scalar-value helper %s"><block var="a"/></custom-block></block><block s="doIf"><block s="reportEquals"><l></l><block s="reportAtomicFindFirst"><block s="reifyPredicate"><autolambda><block s="reportIsA"><l></l><l><option>list</option></l></block></autolambda><list></list></block><block var="b"/></block></block><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="func"/><list><block var="scalarized"/><l></l></list></block></autolambda><list></list></block><block var="b"/></block></block></script></block><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="hyper func"/><list><block var="scalarized"/><l></l></list></block></autolambda><list></list></block><block var="b"/></block></block></script></block></script><script><block s="doIfElse"><custom-block s="scalar? %s"><block var="b"/></custom-block><script><block s="doSetVar"><l>scalarized</l><custom-block s="scalar-value helper %s"><block var="b"/></custom-block></block><block s="doIf"><block s="reportEquals"><l></l><block s="reportAtomicFindFirst"><block s="reifyPredicate"><autolambda><block s="reportIsA"><l></l><l><option>list</option></l></block></autolambda><list></list></block><block var="a"/></block></block><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="func"/><list><l></l><block var="scalarized"/></list></block></autolambda><list></list></block><block var="a"/></block></block></script></block><block s="doReport"><block s="reportMap"><block s="reifyReporter"><autolambda><block s="evaluate"><block var="hyper func"/><list><l></l><block var="scalarized"/></list></block></autolambda><list></list></block><block var="a"/></block></block></script><script><block s="doIf"><block s="reportAnd"><block s="reportEquals"><l></l><block s="reportAtomicFindFirst"><block s="reifyPredicate"><autolambda><block s="reportIsA"><l></l><l><option>list</option></l></block></autolambda><list></list></block><block var="a"/></block></block><block s="reportEquals"><l></l><block s="reportAtomicFindFirst"><block s="reifyPredicate"><autolambda><block s="reportIsA"><l></l><l><option>list</option></l></block></autolambda><list></list></block><block var="b"/></block></block></block><script><block s="doReport"><custom-block s="multimap %repRing over %mult%l"><block var="func"/><list><block var="a"/><block var="b"/></list></custom-block></block></script></block><block s="doReport"><custom-block s="multimap %repRing over %mult%l"><block var="hyper func"/><list><block var="a"/><block var="b"/></list></custom-block></block></script></block></script></block></script></block></script><list><l>a</l><l>b</l></list></block></block><block s="doReport"><block var="hyper func"/></block></script></block-definition><block-definition s="log base %&apos;b&apos; $⍟-1.5-255-255-0 %&apos;x&apos;" type="reporter" category="operators"><comment x="0" y="0" w="212" collapsed="false">Computes logarithms in any base.&#xD;&#xD;The base is the left input.  It&apos;s usual in APL that if there&apos;s a main data input and some sort of control input, the latter comes on the left.  This is because APL syntax, unless you use parentheses, groups computations from right to left.&#xD;&#xD;APL has a monadic version of this function that computes natural logs (log to the base e).</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><custom-block s="simple log base %n of %n"><l></l><l></l></custom-block></autolambda><list></list></block></custom-block><list><block var="b"/><block var="x"/></list></block></block></script></block-definition><block-definition s="combs %&apos;r&apos; at a time $!-1-255-255-0 of %&apos;n&apos;" type="reporter" category="operators"><comment x="0" y="0" w="218.66666666666666" collapsed="false">Computes the number of combinations of right-input things taken left-input at a time, otherwise known as the elements of Pascal&apos;s triangle.  This block shares the ! symbol with the monadic factorial function, because the formula for computing this function uses factorials.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><custom-block s="simple combs %n out of %n"><l></l><l></l></custom-block></autolambda><list></list></block></custom-block><list><block var="r"/><block var="n"/></list></block></block></script></block-definition><block-definition s="factorial $!-1-255-255-0 %&apos;n&apos;" type="reporter" category="operators"><comment x="0" y="0" w="172.66666666666666" collapsed="false">The factorial of a positive integer n is the product of the integers from 1 to n.&#xD;&#xD;In real APL, the domain of this function is extended beyond integers to compute the gamma function.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportIsA"><block var="n"/><l><option>list</option></l></block><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><custom-block s="factorial $!-1-255-255-0 %n"><l></l></custom-block></autolambda><list></list></block><block var="n"/></block></block></script><script><block s="doReport"><block s="reportIfElse"><custom-block s="zero? %n"><block var="n"/></custom-block><l>1</l><block s="reportAtomicCombine"><block s="reportNumbers"><l>1</l><block var="n"/></block><block s="reifyReporter"><autolambda><block s="reportProduct"><l></l><l></l></block></autolambda><list></list></block></block></block></block></script></block></script></block-definition><block-definition s="%&apos;a&apos; scalar %&apos;pred&apos; %&apos;b&apos;" type="predicate" category="operators"><comment x="0" y="0" w="190" collapsed="false">Acts just like the function selected from&#xD;the pulldown menu, but hyperized, so&#xD;comparing two equal-sized lists reports&#xD;a list of the same length as the inputs,&#xD;with the results of item-by-item comparisons.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s" readonly="true">﹦<options>﹦&#xD;≠&#xD;identical to&#xD;and&#xD;or&#xD;is _ a _?</options></input><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reportListItem"><block s="reportListIndex"><block var="pred"/><block s="reportNewList"><list><l>﹦</l><l>≠</l><l>identical to</l><l>and</l><l>or</l><l>is _ a _?</l></list></block></block><block s="reportNewList"><list><block s="reifyPredicate"><autolambda><block s="reportEquals"><l></l><l></l></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportNotEquals"><l></l><l></l></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportIsIdentical"><l></l><l></l></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportAnd"><l/><l/></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportOr"><l/><l/></block></autolambda><list></list></block><block s="reifyPredicate"><autolambda><block s="reportIsA"><l></l><l></l></block></autolambda><list></list></block></list></block></block></custom-block><list><block var="a"/><block var="b"/></list></block></block></script></block-definition><block-definition s="%&apos;howmany&apos; deal $?-1-255-255-0 %&apos;range&apos;" type="reporter" category="operators"><comment x="0" y="0" w="177.33333333333334" collapsed="false">Report a list with left-input random integers in the range 1 to right-input.&#xD;No number appears more than once&#xD;in the result.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="howmany"/><l><option>number</option></l></block><script><block s="doIfElse"><block s="reportEquals"><l></l><block s="reportAtomicFindFirst"><block s="reifyPredicate"><autolambda><block s="reportIsA"><l></l><l><option>list</option></l></block></autolambda><list></list></block><block var="range"/></block></block><script><block s="doReport"><custom-block s="%n deal helper %l"><block var="howmany"/><block s="reportNumbers"><l>1</l><block var="range"/></block></custom-block></block></script><script><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><custom-block s="%n deal $?-1-255-255-0 %n"><block var="howmany"/><l></l></custom-block></autolambda><list></list></block><block var="range"/></block></block></script></block></script></block><block s="doReport"><block s="reportAtomicMap"><block s="reifyReporter"><autolambda><custom-block s="%n deal $?-1-255-255-0 %n"><l></l><block var="range"/></custom-block></autolambda><list></list></block><block var="howmany"/></block></block></script></block-definition><block-definition s="GCD (or) %&apos;a&apos; $∨-1.2-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="230.66666666666666" collapsed="false">Reports the greatest common divisor of its inputs.&#xD;If the inputs are values in {0,1} then this is equivalent to the logical OR of the values, with 0=False, 1=True.  Hence the APL symbol ∨.&#xD;Also accepts Snap! Booleans as inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><custom-block s="simple gcd %n %n"><l></l><l></l></custom-block></autolambda><list></list></block></custom-block><list><custom-block s="de-boolean %s"><block var="a"/></custom-block><custom-block s="de-boolean %s"><block var="b"/></custom-block></list></block></block></script></block-definition><block-definition s="LCM (and) %&apos;a&apos; $∧-1.2-255-255-0 %&apos;b&apos;" type="reporter" category="operators"><comment x="0" y="0" w="230.66666666666666" collapsed="false">Reports the least common multiple of its inputs.&#xD;If the inputs are values in {0,1} then this is equivalent to the logical AND of the values, with 0=False, 1=True.  Hence the APL symbol ∧.&#xD;Also accepts Snap! Booleans as inputs.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><custom-block s="simple lcm %n %n"><l></l><l></l></custom-block></autolambda><list></list></block></custom-block><list><custom-block s="de-boolean %s"><block var="a"/></custom-block><custom-block s="de-boolean %s"><block var="b"/></custom-block></list></block></block></script></block-definition><block-definition s="NOT $&#126;-1-255-255-0 %&apos;p&apos;" type="reporter" category="operators"><comment x="0" y="0" w="167.33333333333334" collapsed="false">Reports 1 if the input is False or 0;&#xD;otherwise reports 0.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="reportDifference"><l>1</l><custom-block s="signum $×-1-255-255-0 %n"><block s="reportMonadic"><l><option>abs</option></l><block var="p"/></block></custom-block></block></block></script></block-definition><block-definition s="permutations of %&apos;r&apos; items out of %&apos;n&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="evaluate"><custom-block s="scalar -&gt; hyper %repRing"><block s="reifyReporter"><autolambda><custom-block s="simple permutations of %n items out of %n"><l></l><l></l></custom-block></autolambda><list></list></block></custom-block><list><block var="r"/><block var="n"/></list></block></block></script></block-definition><block-definition s="identity $+-1-255-255-0 %&apos;x&apos;" type="reporter" category="operators"><comment x="0" y="0" w="210.00000000000003" collapsed="false">Reports its input.&#xD;This is useful to fit a value into a different-type input slot, e.g., number into list slot.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="reportMonadic"><l><option>id</option></l><block var="x"/></block></block></script></block-definition></blocks>