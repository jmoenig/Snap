<blocks app="Snap! 6, https://snap.berkeley.edu" version="1"><block-definition s="%&apos;head&apos; in front of stream %&apos;tail&apos;" type="reporter" category="lists"><comment w="418.6106770833333" collapsed="false">The stream version of IN FRONT OF.&#xD;&#xD;Streams, also called lazy lists, are like lists except that&#xD;items are not computed until they&apos;re needed.  This allows&#xD;for more efficient handling of large computed lists, and&#xD;even infinite lists.  The only piece of magic is here in &#xD;IN FRONT OF STREAM, whose second input is of type &#xD;Unevaluated, which means that it&apos;s a procedure, with &#xD;a sort of invisible gray ring. So HEAD OF STREAM is just &#xD;ITEM 1 OF, but TAIL OF STREAM has a CALL block &#xD;to make the computation happen.&#xD;&#xD;For a tutorial introduction to streams, read SICP 3.5:&#xD;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5&#xD;or Brian&apos;s lecture notes (start on page 74):&#xD;https://people.eecs.berkeley.edu/&#126;bh/61a-pages/Volume2/notes.pdf&#xD;The above are clickable links!</comment><header></header><code></code><translations>pt:a prefixação de _ ao canal _&#xD;</translations><inputs><input type="%s"></input><input type="%anyUE"></input></inputs><script><block s="doReport"><block s="reportNewList"><list><block var="head"/><block var="tail"/><block s="reportBoolean"><l><bool>false</bool></l></block><block s="reportBoolean"><l><bool>false</bool></l></block></list></block></block></script></block-definition><block-definition s="head of stream %&apos;stream&apos;" type="reporter" category="lists"><comment w="418.6106770833333" collapsed="false">The stream version of ITEM 1 OF.&#xD;&#xD;Streams, also called lazy lists, are like lists except that&#xD;items are not computed until they&apos;re needed.  This allows&#xD;for more efficient handling of large computed lists, and&#xD;even infinite lists.  The only piece of magic is in &#xD;IN FRONT OF STREAM, whose second input is of type &#xD;Unevaluated, which means that it&apos;s a procedure, with &#xD;a sort of invisible gray ring. So HEAD OF STREAM is just &#xD;ITEM 1 OF, but TAIL OF STREAM has a CALL block &#xD;to make the computation happen.&#xD;&#xD;For a tutorial introduction to streams, read SICP 3.5:&#xD;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5&#xD;or Brian&apos;s lecture notes (start on page 74):&#xD;https://people.eecs.berkeley.edu/&#126;bh/61a-pages/Volume2/notes.pdf&#xD;The above are clickable links!</comment><header></header><code></code><translations>pt:o primeiro item do canal _&#xD;</translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="stream"/></block></block></script></block-definition><block-definition s="tail of stream %&apos;stream&apos;" type="reporter" category="lists"><comment w="418.6106770833333" collapsed="false">The stream version of ALL BUT FIRST OF.&#xD;&#xD;Streams, also called lazy lists, are like lists except that&#xD;items are not computed until they&apos;re needed.  This allows&#xD;for more efficient handling of large computed lists, and&#xD;even infinite lists.  The only piece of magic is in &#xD;IN FRONT OF STREAM, whose second input is of type &#xD;Unevaluated, which means that it&apos;s a procedure, with &#xD;a sort of invisible gray ring. So HEAD OF STREAM is just &#xD;ITEM 1 OF, but TAIL OF STREAM has a CALL block &#xD;to make the computation happen.&#xD;&#xD;For a tutorial introduction to streams, read SICP 3.5:&#xD;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5&#xD;or Brian&apos;s lecture notes (start on page 74):&#xD;https://people.eecs.berkeley.edu/&#126;bh/61a-pages/Volume2/notes.pdf&#xD;The above are clickable links!</comment><header></header><code></code><translations>pt:um canal com todos os itens de _ menos o primeiro&#xD;</translations><inputs><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doIf"><block s="reportListItem"><l>3</l><block var="stream"/></block><script><block s="doReport"><block s="reportListItem"><l>4</l><block var="stream"/></block></block></script></block><block s="doReplaceInList"><l>4</l><block var="stream"/><block s="evaluate"><block s="reportListItem"><l>2</l><block var="stream"/></block><list></list></block></block><block s="doReplaceInList"><l>3</l><block var="stream"/><block s="reportBoolean"><l><bool>true</bool></l></block></block><block s="doReport"><block s="reportListItem"><l>4</l><block var="stream"/></block></block></script></block></script></block-definition><block-definition s="map %&apos;function&apos; over stream %&apos;stream&apos;" type="reporter" category="lists"><comment w="418.6106770833333" collapsed="false">The stream version of variadic MAP (any number of input lists, like&#xD;MULTIMAP in the list utilities library).&#xD;&#xD;Streams, also called lazy lists, are like lists except that&#xD;items are not computed until they&apos;re needed.  This allows&#xD;for more efficient handling of large computed lists, and&#xD;even infinite lists.  The only piece of magic is in &#xD;IN FRONT OF STREAM, whose second input is of type &#xD;Unevaluated, which means that it&apos;s a procedure, with &#xD;a sort of invisible gray ring. So HEAD OF STREAM is just &#xD;ITEM 1 OF, but TAIL OF STREAM has a CALL block &#xD;to make the computation happen.&#xD;&#xD;For a tutorial introduction to streams, read SICP 3.5:&#xD;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5&#xD;or Brian&apos;s lecture notes (start on page 74):&#xD;https://people.eecs.berkeley.edu/&#126;bh/61a-pages/Volume2/notes.pdf&#xD;The above are clickable links!</comment><header></header><code></code><translations>pt:a aplicação de _ aos itens dos canais _&#xD;</translations><inputs><input type="%repRing"></input><input type="%mult%l"></input></inputs><script><block s="doWarp"><script><block s="doIf"><block s="reportEquals"><block s="reportListItem"><l>1</l><block var="stream"/></block><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doReport"><custom-block s="%s in front of stream %anyUE"><block s="evaluate"><block var="function"/><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="head of stream %l"><l/></custom-block></autolambda><list></list></block><block var="stream"/></block></block><custom-block s="map %repRing over stream %mult%l"><block var="function"/><block s="reportMap"><block s="reifyReporter"><autolambda><custom-block s="tail of stream %l"><l/></custom-block></autolambda><list></list></block><block var="stream"/></block></custom-block></custom-block></block></script></block></script></block-definition><block-definition s="keep items such that %&apos;pred&apos; from stream %&apos;stream&apos;" type="reporter" category="lists"><comment w="418.6106770833333" collapsed="false">The stream version of KEEP.&#xD;&#xD;Streams, also called lazy lists, are like lists except that&#xD;items are not computed until they&apos;re needed.  This allows&#xD;for more efficient handling of large computed lists, and&#xD;even infinite lists.  The only piece of magic is in &#xD;IN FRONT OF STREAM, whose second input is of type &#xD;Unevaluated, which means that it&apos;s a procedure, with &#xD;a sort of invisible gray ring. So HEAD OF STREAM is just &#xD;ITEM 1 OF, but TAIL OF STREAM has a CALL block &#xD;to make the computation happen.&#xD;&#xD;For a tutorial introduction to streams, read SICP 3.5:&#xD;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5&#xD;or Brian&apos;s lecture notes (start on page 74):&#xD;https://people.eecs.berkeley.edu/&#126;bh/61a-pages/Volume2/notes.pdf&#xD;The above are clickable links!</comment><header></header><code></code><translations>pt:os itens tais que _ do canal _&#xD;</translations><inputs><input type="%predRing"></input><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doIf"><block s="reportEquals"><block var="stream"/><block s="reportNewList"><list></list></block></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doIfElse"><block s="evaluate"><block var="pred"/><list><custom-block s="head of stream %l"><block var="stream"/></custom-block></list></block><script><block s="doReport"><custom-block s="%s in front of stream %anyUE"><custom-block s="head of stream %l"><block var="stream"/></custom-block><custom-block s="keep items such that %predRing from stream %l"><block var="pred"/><custom-block s="tail of stream %l"><block var="stream"/></custom-block></custom-block></custom-block></block></script><script><block s="doReport"><custom-block s="keep items such that %predRing from stream %l"><block var="pred"/><custom-block s="tail of stream %l"><block var="stream"/></custom-block></custom-block></block></script></block></script></block></script></block-definition><block-definition s="show stream %&apos;stream&apos; %&apos;number&apos;" type="reporter" category="lists"><comment w="364" collapsed="false">The inputs are a stream and a positive integer.  SHOW STREAM reports a&#xD;regular finite list of length less than (for short finite streams) or equal to the&#xD;second input.  It&apos;s useful because an infinite stream can&apos;t be displayed in a&#xD;finite amount of time.</comment><header></header><code></code><translations>pt:uma lista com os itens do canal _ até ao _ º&#xD;</translations><inputs><input type="%l"></input><input type="%n">10</input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="stream"/></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doIf"><block s="reportEquals"><block var="number"/><l>0</l></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script></block><block s="doReport"><block s="reportCONS"><custom-block s="head of stream %l"><block var="stream"/></custom-block><custom-block s="show stream %l %n"><custom-block s="tail of stream %l"><block var="stream"/></custom-block><block s="reportDifference"><block var="number"/><l>1</l></block></custom-block></block></block></script></block-definition><block-definition s="stream %&apos;items&apos;" type="reporter" category="lists"><comment w="343.3333333333333" collapsed="false">Make a stream from a finite collection of items, like the LIST primitive.&#xD;Since this block is typically used for small amounts of data, it does not&#xD;delay computation of its inputs.</comment><header></header><code></code><translations>pt:um canal com _&#xD;</translations><inputs><input type="%mult%s"></input></inputs><script><block s="doIf"><block s="reportListIsEmpty"><block var="items"/></block><script><block s="doReport"><block var="items"/></block></script></block><block s="doReport"><custom-block s="%s in front of stream %anyUE"><block s="reportListItem"><l>1</l><block var="items"/></block><custom-block s="stream %mult%s"><block s="reportCDR"><block var="items"/></block></custom-block></custom-block></block></script></block-definition><block-definition s="sieve %&apos;stream&apos;" type="reporter" category="lists"><comment w="478" collapsed="false">Call this block with STREAM WITH NUMBERS FROM 2&#xD;as its input to get the infinite stream of all the prime numbers.&#xD;&#xD;It&apos;s called SIEVE because the algorithm it uses is the Sieve of&#xD;Eratosthenes (clickable link):&#xD;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&#xD;&#xD;Look inside; it&apos;s a beautifully elegant algorithm.&#xD;&#xD;For a tutorial introduction to streams, read SICP 3.5:&#xD;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5&#xD;or Brian&apos;s lecture notes (start on page 74):&#xD;https://people.eecs.berkeley.edu/&#126;bh/61a-pages/Volume2/notes.pdf&#xD;The above are clickable links!</comment><header></header><code></code><translations>pt:a crivagem do canal _&#xD;</translations><inputs><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doReport"><custom-block s="%s in front of stream %anyUE"><custom-block s="head of stream %l"><block var="stream"/></custom-block><custom-block s="sieve %l"><custom-block s="keep items such that %predRing from stream %l"><block s="reifyPredicate"><autolambda><block s="reportGreaterThan"><block s="reportModulus"><l></l><custom-block s="head of stream %l"><block var="stream"/></custom-block></block><l>0</l></block></autolambda><list></list></block><custom-block s="tail of stream %l"><block var="stream"/></custom-block></custom-block></custom-block></custom-block></block></script></block></script></block-definition><block-definition s="stream with numbers from %&apos;start&apos;" type="reporter" category="lists"><comment w="418.6106770833333" collapsed="false">The stream version of NUMBERS FROM 1 TO, with no&#xD;ending number because it reports the infinite stream of all&#xD;the integers greater than or equal to its input.&#xD;&#xD;Read the code!  It&apos;s deceptively simple.&#xD;&#xD;Streams, also called lazy lists, are like lists except that&#xD;items are not computed until they&apos;re needed.  This allows&#xD;for more efficient handling of large computed lists, and&#xD;even infinite lists.  The only piece of magic is in &#xD;IN FRONT OF STREAM, whose second input is of type &#xD;Unevaluated, which means that it&apos;s a procedure, with &#xD;a sort of invisible gray ring. So HEAD OF STREAM is just &#xD;ITEM 1 OF, but TAIL OF STREAM has a CALL block &#xD;to make the computation happen.&#xD;&#xD;For a tutorial introduction to streams, read SICP 3.5:&#xD;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5&#xD;or Brian&apos;s lecture notes (start on page 74):&#xD;https://people.eecs.berkeley.edu/&#126;bh/61a-pages/Volume2/notes.pdf&#xD;The above are clickable links!</comment><header></header><code></code><translations>pt:um canal com os números a partir de _&#xD;</translations><inputs><input type="%n">1</input></inputs><script><block s="doReport"><custom-block s="%s in front of stream %anyUE"><block var="start"/><custom-block s="stream with numbers from %n"><block s="reportSum"><block var="start"/><l>1</l></block></custom-block></custom-block></block></script></block-definition><block-definition s="stream demo" type="command" category="lists"><comment w="174.66666666666666" collapsed="true">Read the code while running it, </comment><header></header><code></code><translations></translations><inputs></inputs><script><block s="doDeclareVariables"><list><l>ones</l><l>ints</l><l>primes</l></list></block><block s="doSetVar"><l>ones</l><custom-block s="%s in front of stream %anyUE"><l>1</l><block var="ones"/></custom-block></block><block s="doSetVar"><l>ints</l><custom-block s="%s in front of stream %anyUE"><l>1</l><custom-block s="map %repRing over stream %mult%l"><block s="reifyReporter"><autolambda><block s="reportSum"><l></l><l></l></block></autolambda><list></list></block><list><block var="ones"/><block var="ints"/></list></custom-block></custom-block></block><block s="doSetVar"><l>primes</l><custom-block s="sieve %l"><custom-block s="stream with numbers from %n"><l>2</l></custom-block></custom-block></block><block s="doSayFor"><custom-block s="show stream %l %n"><block var="ones"/><l>10</l></custom-block><l>2</l></block><block s="doSayFor"><custom-block s="show stream %l %n"><block var="ints"/><l>10</l></custom-block><l>2</l></block><block s="doSayFor"><custom-block s="show stream %l %n"><block var="primes"/><l>10</l></custom-block><l>2</l></block></script></block-definition></blocks>